import { TFile, Vault, Notice } from 'obsidian';
import { FoodItem, NutritionData } from '../types/nutrition';
import { PluginSettings } from '../types/settings';

export class FileService {
  constructor(private vault: Vault, private settings: PluginSettings) {}

  async createOrUpdateFoodLog(foodItems: FoodItem[], replaceEntry?: { food: string, quantity: string, calories: number, protein: number, carbs: number, fat: number }): Promise<void> {
    const today = this.getTodayString();
    const logPath = `${this.settings.logStoragePath}/${today}.md`;
    
    try {
      // Ensure the directory exists
      await this.ensureDirectoryExists(this.settings.logStoragePath);
      
      // Check if file already exists
      const existingFile = this.vault.getAbstractFileByPath(logPath);
      
      if (existingFile instanceof TFile) {
        if (replaceEntry) {
          // Replace existing entry
          await this.replaceInExistingLog(existingFile, foodItems, replaceEntry);
        } else {
          // Append to existing file
          await this.appendToExistingLog(existingFile, foodItems);
        }
      } else {
        // Create new file
        await this.createNewFoodLog(logPath, foodItems);
      }
      
      if (replaceEntry) {
        new Notice(`‚úèÔ∏è Food entry replaced in: ${today}.md`);
      } else {
        new Notice(`Food log updated: ${today}.md`);
      }
    } catch (error) {
      console.error('Error creating/updating food log:', error);
      throw new Error(`Failed to save food log: ${error.message}`);
    }
  }

  private async createNewFoodLog(path: string, foodItems: FoodItem[]): Promise<void> {
    const content = await this.generateFoodLogContent(foodItems, true);
    await this.vault.create(path, content);
  }

  private async appendToExistingLog(file: TFile, foodItems: FoodItem[]): Promise<void> {
    const existingContent = await this.vault.read(file);
    const newEntries = await this.generateFoodLogContent(foodItems, false);
    
    // Find the position to insert new entries (before the daily summary)
    const summaryRegex = /## üìä Daily Summary[\s\S]*$/;
    const match = existingContent.match(summaryRegex);
    
    if (match) {
      // Remove the existing summary and insert new entries
      const beforeSummary = existingContent.substring(0, match.index);
      const updatedContent = beforeSummary + newEntries;
      
      // Recalculate totals (this will add the new summary)
      const finalContent = await this.recalculateTotals(updatedContent);
      await this.vault.modify(file, finalContent);
    } else {
      // No summary found, just append new entries and add summary
      const updatedContent = existingContent + '\n' + newEntries;
      const allFoodItems = this.extractFoodItemsFromContent(updatedContent);
      const totals = this.calculateTotals(allFoodItems);
      const summary = await this.generateDailySummary(totals);
      const finalContent = updatedContent + '\n' + summary + '\n---\n\n*‚ú® Generated by AI Nutrition Tracker Plugin*\n';
      await this.vault.modify(file, finalContent);
    }
  }

  private async replaceInExistingLog(file: TFile, newFoodItems: FoodItem[], originalEntry: { food: string, quantity: string, calories: number, protein: number, carbs: number, fat: number }): Promise<void> {
    const existingContent = await this.vault.read(file);
    
    // Find and replace the card in its original position
    const replacement = this.replaceCardInPosition(existingContent, originalEntry, newFoodItems);
    if (replacement.success) {
      console.log('Successfully replaced entry in original position');
      // Recalculate totals and update summary
      const finalContent = await this.recalculateTotals(replacement.content);
      await this.vault.modify(file, finalContent);
    } else {
      console.warn('Original entry not found for replacement, falling back to append');
      // Fallback to the old append logic
      await this.appendToExistingLog(file, newFoodItems);
    }
  }

  private replaceCardInPosition(content: string, originalEntry: { food: string, quantity: string, calories: number, protein: number, carbs: number, fat: number }, newFoodItems: FoodItem[]): { success: boolean, content: string } {
    // Find the start of the card using data attributes
    const escapedFood = originalEntry.food.replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/"/g, '&quot;');
    const escapedQuantity = originalEntry.quantity.replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/"/g, '&quot;');
    
    const cardPosition = this.findCardPosition(content, escapedFood, escapedQuantity, originalEntry.calories);
    if (!cardPosition.success) {
      return { success: false, content };
    }
    
    // Generate the new card content
    const newCardContent = this.generateCardLayout(newFoodItems);
    
    // Replace the old card with the new card at the exact position
    const beforeCard = content.substring(0, cardPosition.startIndex);
    const afterCard = content.substring(cardPosition.endIndex);
    
    // Clean up any extra whitespace and insert new card
    const cleanedAfter = afterCard.replace(/^\s*\n\s*/, '\n');
    const updatedContent = beforeCard + newCardContent.trim() + cleanedAfter;
    
    return { success: true, content: updatedContent };
  }

  private findCardPosition(content: string, escapedFood: string, escapedQuantity: string, calories: number): { success: boolean, startIndex: number, endIndex: number } {
    // Look for cards with complete nutrition data
    const startPattern = new RegExp(
      `<div[^>]*data-ntr-food="${escapedFood}"[^>]*data-ntr-quantity="${escapedQuantity}"[^>]*data-ntr-calories="${calories}"[^>]*data-ntr-protein="[^"]*"[^>]*data-ntr-carbs="[^"]*"[^>]*data-ntr-fat="[^"]*"[^>]*>`,
      'gi'
    );
    
    const startMatch = startPattern.exec(content);
    if (!startMatch) {
      // Try legacy pattern without complete nutrition data
      const legacyPattern = new RegExp(
        `<div[^>]*data-ntr-food="${escapedFood}"[^>]*data-ntr-quantity="${escapedQuantity}"[^>]*data-ntr-calories="${calories}"[^>]*>`,
        'gi'
      );
      const legacyMatch = legacyPattern.exec(content);
      if (!legacyMatch) {
        return { success: false, startIndex: -1, endIndex: -1 };
      }
      const cardBounds = this.findCardBounds(content, legacyMatch.index);
      return { success: cardBounds.success, startIndex: legacyMatch.index, endIndex: cardBounds.endIndex };
    }
    
    const cardBounds = this.findCardBounds(content, startMatch.index);
    return { success: cardBounds.success, startIndex: startMatch.index, endIndex: cardBounds.endIndex };
  }

  private findCardBounds(content: string, startIndex: number): { success: boolean, endIndex: number } {
    let divCount = 0;
    let i = startIndex;
    
    // Find the opening div
    while (i < content.length && content.charAt(i) !== '>') {
      i++;
    }
    i++; // Move past the >
    divCount = 1;
    
    // Count divs to find the matching closing div
    while (i < content.length && divCount > 0) {
      if (content.substring(i, i + 4) === '<div') {
        divCount++;
        i += 4;
      } else if (content.substring(i, i + 6) === '</div>') {
        divCount--;
        if (divCount === 0) {
          return { success: true, endIndex: i + 6 };
        }
        i += 6;
      } else {
        i++;
      }
    }
    
    return { success: false, endIndex: -1 };
  }

  private findAndReplaceCompleteCard(content: string, originalEntry: { food: string, quantity: string, calories: number, protein: number, carbs: number, fat: number }): { success: boolean, content: string } {
    // Find the start of the entry using data attributes
    const escapedFood = originalEntry.food.replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/"/g, '&quot;');
    const escapedQuantity = originalEntry.quantity.replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/"/g, '&quot;');
    
    // Try card layout attributes first (data-ntr-*) - new format with complete nutrition data
    const cardPattern = new RegExp(
      `<div[^>]*data-ntr-food="${escapedFood}"[^>]*data-ntr-quantity="${escapedQuantity}"[^>]*data-ntr-calories="${originalEntry.calories}"[^>]*data-ntr-protein="${originalEntry.protein}"[^>]*data-ntr-carbs="${originalEntry.carbs}"[^>]*data-ntr-fat="${originalEntry.fat}"[^>]*>`,
      'gi'
    );
    
    let startMatch = cardPattern.exec(content);
    if (!startMatch) {
      // Try legacy card pattern without complete nutrition data
      const legacyCardPattern = new RegExp(
        `<div[^>]*data-ntr-food="${escapedFood}"[^>]*data-ntr-quantity="${escapedQuantity}"[^>]*data-ntr-calories="${originalEntry.calories}"[^>]*>`,
        'gi'
      );
      startMatch = legacyCardPattern.exec(content);
    }
    
    if (!startMatch) {
      // Try simple layout attributes (data-*)
      const simplePattern = new RegExp(
        `<div[^>]*data-food="${escapedFood}"[^>]*data-quantity="${escapedQuantity}"[^>]*data-calories="${originalEntry.calories}"[^>]*>`,
        'gi'
      );
      startMatch = simplePattern.exec(content);
      
      if (!startMatch) {
        // Try alternative simple attribute order
        const simplePattern2 = new RegExp(
          `<div[^>]*data-calories="${originalEntry.calories}"[^>]*data-food="${escapedFood}"[^>]*data-quantity="${escapedQuantity}"[^>]*>`,
          'gi'
        );
        startMatch = simplePattern2.exec(content);
      }
    }
    
    if (!startMatch) {
      return { success: false, content };
    }
    
    return this.extractCompleteCard(content, startMatch.index);
  }

  private extractCompleteCard(content: string, startIndex: number): { success: boolean, content: string } {
    let divCount = 0;
    let i = startIndex;
    let cardStart = startIndex;
    let cardEnd = -1;
    
    // Find the opening div
    while (i < content.length && content.charAt(i) !== '>') {
      i++;
    }
    i++; // Move past the >
    divCount = 1;
    
    // Count divs to find the matching closing div
    while (i < content.length && divCount > 0) {
      if (content.substring(i, i + 4) === '<div') {
        divCount++;
        i += 4;
      } else if (content.substring(i, i + 6) === '</div>') {
        divCount--;
        if (divCount === 0) {
          cardEnd = i + 6;
          break;
        }
        i += 6;
      } else {
        i++;
      }
    }
    
    if (cardEnd === -1) {
      return { success: false, content };
    }
    
    // Extract the complete card and remove it
    const beforeCard = content.substring(0, cardStart);
    const afterCard = content.substring(cardEnd);
    
    // Clean up any extra whitespace/newlines
    const cleanedContent = beforeCard + afterCard.replace(/^\s*\n\s*/, '\n');
    
    return { success: true, content: cleanedContent };
  }

  private async generateFoodLogContent(foodItems: FoodItem[], isNewFile: boolean): Promise<string> {
    const today = this.getTodayString();
    const totals = this.calculateTotals(foodItems);
    
    let content = '';
    
    if (isNewFile) {
      content += `# üçΩÔ∏è Food Log ${today}\n\n`;
      content += `## ü•ó Today's Meals\n\n`;
    }
    
    // Generate food items based on layout style
    if (this.settings.layoutStyle === 'cards') {
      content += this.generateCardLayout(foodItems);
    } else {
      content += this.generateSimpleLayout(foodItems);
    }
    
    if (isNewFile) {
      content += await this.generateDailySummary(totals);
      content += '\n---\n\n';
      content += '*‚ú® Generated by AI Nutrition Tracker Plugin*\n';
    }
    
    return content;
  }

  private generateCardLayout(foodItems: FoodItem[]): string {
    let content = '';
    const isDarkTheme = this.getEffectiveTheme() === 'dark';
    
    for (const item of foodItems) {
      const emoji = this.getFoodEmoji(item.food);
      const timeStr = item.timestamp ? 
        new Date(item.timestamp).toLocaleTimeString('en-US', { 
          hour: '2-digit', 
          minute: '2-digit' 
        }) : '';
      
      if (isDarkTheme) {
        // Glassy dark theme card
        const entryId = `ntr-${Date.now()}-${Math.random().toString(36).substr(2, 6)}`;
        content += `\n<div id="${entryId}" data-ntr-food="${item.food.replace(/"/g, '&quot;')}" data-ntr-quantity="${item.quantity.replace(/"/g, '&quot;')}" data-ntr-calories="${item.calories}" data-ntr-protein="${item.protein}" data-ntr-carbs="${item.carbs}" data-ntr-fat="${item.fat}" style="background: linear-gradient(135deg, rgba(30, 41, 59, 0.75), rgba(51, 65, 85, 0.75)); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-radius: 16px; padding: 14px; margin: 10px 0; box-shadow: 0 8px 32px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.1); border: 1px solid rgba(148,163,184,0.2); position: relative; overflow: hidden;">\n`;
        content += `  <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">\n`;
        content += `    <div style="display: flex; align-items: center;">\n`;
        content += `      <span style="font-size: 32px; margin-right: 10px;">${emoji}</span>\n`;
        content += `      <div>\n`;
        content += `        <h3 style="color: #f8fafc; margin: 0; font-size: 16px; font-weight: 600;">${item.food}</h3>\n`;
        content += `        <div style="color: #94a3b8; font-size: 12px; margin-top: 2px;">üìè ${item.quantity}</div>\n`;
        content += `      </div>\n`;
        content += `    </div>\n`;
        if (timeStr) {
          content += `    <div style="position: absolute; top: 8px; right: 8px; background: linear-gradient(135deg, rgba(0,0,0,0.15), rgba(30,41,59,0.1)); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); padding: 2px 6px; border-radius: 8px; font-size: 10px; color: #cbd5e1; border: 1px solid rgba(255,255,255,0.08); max-width: calc(100% - 120px); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">üïê ${timeStr}</div>\n`;
        }
        content += `    <button class="nutrition-edit-btn" data-food="${item.food.replace(/"/g, '&quot;')}" data-quantity="${item.quantity.replace(/"/g, '&quot;')}" data-calories="${item.calories}" data-protein="${item.protein}" data-carbs="${item.carbs}" data-fat="${item.fat}" style="background: linear-gradient(135deg, rgba(148,163,184,0.12), rgba(100,116,139,0.08)); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border: 1px solid rgba(148,163,184,0.25); border-radius: 8px; padding: 4px 8px; color: #cbd5e1; font-size: 10px; cursor: pointer; margin-left: 8px; box-shadow: 0 2px 8px rgba(148,163,184,0.1), inset 0 1px 0 rgba(255,255,255,0.1);">‚úèÔ∏è Edit</button>\n`;
        content += `  </div>\n`;
        content += `  <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px;">\n`;
        content += `    <div style="text-align: center; padding: 8px; background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(185, 28, 28, 0.1)); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border-radius: 12px; border: 1px solid rgba(239, 68, 68, 0.25); box-shadow: 0 4px 16px rgba(239, 68, 68, 0.1);">\n`;
        content += `      <div style="font-size: 16px; margin-bottom: 2px;">üî•</div>\n`;
        content += `      <div style="color: #fecaca; font-weight: bold; font-size: 14px;">${item.calories}</div>\n`;
        content += `      <div style="color: #f87171; font-size: 9px; text-transform: uppercase; font-weight: 500;">kcal</div>\n`;
        content += `    </div>\n`;
        content += `    <div style="text-align: center; padding: 8px; background: linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(22, 163, 74, 0.1)); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border-radius: 12px; border: 1px solid rgba(34, 197, 94, 0.25); box-shadow: 0 4px 16px rgba(34, 197, 94, 0.1);">\n`;
        content += `      <div style="font-size: 16px; margin-bottom: 2px;">üí™</div>\n`;
        content += `      <div style="color: #bbf7d0; font-weight: bold; font-size: 14px;">${item.protein}g</div>\n`;
        content += `      <div style="color: #86efac; font-size: 9px; text-transform: uppercase; font-weight: 500;">protein</div>\n`;
        content += `    </div>\n`;
        content += `    <div style="text-align: center; padding: 8px; background: linear-gradient(135deg, rgba(251, 191, 36, 0.2), rgba(217, 119, 6, 0.1)); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border-radius: 12px; border: 1px solid rgba(251, 191, 36, 0.25); box-shadow: 0 4px 16px rgba(251, 191, 36, 0.1);">\n`;
        content += `      <div style="font-size: 16px; margin-bottom: 2px;">üåæ</div>\n`;
        content += `      <div style="color: #fde68a; font-weight: bold; font-size: 14px;">${item.carbs}g</div>\n`;
        content += `      <div style="color: #fbbf24; font-size: 9px; text-transform: uppercase; font-weight: 500;">carbs</div>\n`;
        content += `    </div>\n`;
        content += `    <div style="text-align: center; padding: 8px; background: linear-gradient(135deg, rgba(168, 85, 247, 0.2), rgba(124, 58, 237, 0.1)); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border-radius: 12px; border: 1px solid rgba(168, 85, 247, 0.25); box-shadow: 0 4px 16px rgba(168, 85, 247, 0.1);">\n`;
        content += `      <div style="font-size: 16px; margin-bottom: 2px;">ü•ë</div>\n`;
        content += `      <div style="color: #ddd6fe; font-weight: bold; font-size: 14px;">${item.fat}g</div>\n`;
        content += `      <div style="color: #c4b5fd; font-size: 9px; text-transform: uppercase; font-weight: 500;">fat</div>\n`;
        content += `    </div>\n`;
        content += `  </div>\n`;
        content += `</div>\n\n`;
      } else {
        // Glassy light theme card
        const entryId = `ntr-${Date.now()}-${Math.random().toString(36).substr(2, 6)}`;
        content += `\n<div id="${entryId}" data-ntr-food="${item.food.replace(/"/g, '&quot;')}" data-ntr-quantity="${item.quantity.replace(/"/g, '&quot;')}" data-ntr-calories="${item.calories}" data-ntr-protein="${item.protein}" data-ntr-carbs="${item.carbs}" data-ntr-fat="${item.fat}" style="background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(248, 250, 252, 0.9)); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-radius: 16px; padding: 14px; margin: 10px 0; box-shadow: 0 8px 32px rgba(0,0,0,0.08), inset 0 1px 0 rgba(255,255,255,0.9); border: 1px solid rgba(255,255,255,0.6); position: relative; overflow: hidden;">\n`;
        content += `  <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">\n`;
        content += `    <div style="display: flex; align-items: center;">\n`;
        content += `      <span style="font-size: 32px; margin-right: 10px;">${emoji}</span>\n`;
        content += `      <div>\n`;
        content += `        <h3 style="color: #0f172a; margin: 0; font-size: 16px; font-weight: 600;">${item.food}</h3>\n`;
        content += `        <div style="color: #64748b; font-size: 12px; margin-top: 2px;">üìè ${item.quantity}</div>\n`;
        content += `      </div>\n`;
        content += `    </div>\n`;
        if (timeStr) {
          content += `    <div style="position: absolute; top: 8px; right: 8px; background: linear-gradient(135deg, rgba(255,255,255,0.7), rgba(248,250,252,0.4)); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); padding: 2px 6px; border-radius: 8px; font-size: 10px; color: #64748b; border: 1px solid rgba(255,255,255,0.6); max-width: calc(100% - 120px); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">üïê ${timeStr}</div>\n`;
        }
        content += `    <button class="nutrition-edit-btn" data-food="${item.food.replace(/"/g, '&quot;')}" data-quantity="${item.quantity.replace(/"/g, '&quot;')}" data-calories="${item.calories}" data-protein="${item.protein}" data-carbs="${item.carbs}" data-fat="${item.fat}" style="background: linear-gradient(135deg, rgba(255,255,255,0.7), rgba(248,250,252,0.5)); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border: 1px solid rgba(255,255,255,0.6); border-radius: 8px; padding: 4px 8px; color: #475569; font-size: 10px; cursor: pointer; margin-left: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.08), inset 0 1px 0 rgba(255,255,255,0.8);">‚úèÔ∏è Edit</button>\n`;
        content += `  </div>\n`;
        content += `  <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px;">\n`;
        content += `    <div style="text-align: center; padding: 8px; background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(254, 226, 226, 0.9)); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border-radius: 12px; border: 1px solid rgba(252, 165, 165, 0.3); box-shadow: 0 4px 16px rgba(239, 68, 68, 0.06), inset 0 1px 0 rgba(255,255,255,0.8);">\n`;
        content += `      <div style="font-size: 16px; margin-bottom: 2px;">üî•</div>\n`;
        content += `      <div style="color: #dc2626; font-weight: bold; font-size: 14px;">${item.calories}</div>\n`;
        content += `      <div style="color: #ef4444; font-size: 9px; text-transform: uppercase; font-weight: 600;">KCAL</div>\n`;
        content += `    </div>\n`;
        content += `    <div style="text-align: center; padding: 8px; background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(220, 252, 231, 0.9)); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border-radius: 12px; border: 1px solid rgba(134, 239, 172, 0.3); box-shadow: 0 4px 16px rgba(34, 197, 94, 0.06), inset 0 1px 0 rgba(255,255,255,0.8);">\n`;
        content += `      <div style="font-size: 16px; margin-bottom: 2px;">üí™</div>\n`;
        content += `      <div style="color: #16a34a; font-weight: bold; font-size: 14px;">${item.protein}g</div>\n`;
        content += `      <div style="color: #22c55e; font-size: 9px; text-transform: uppercase; font-weight: 600;">PROTEIN</div>\n`;
        content += `    </div>\n`;
        content += `    <div style="text-align: center; padding: 8px; background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(254, 243, 199, 0.9)); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border-radius: 12px; border: 1px solid rgba(252, 211, 77, 0.3); box-shadow: 0 4px 16px rgba(251, 191, 36, 0.06), inset 0 1px 0 rgba(255,255,255,0.8);">\n`;
        content += `      <div style="font-size: 16px; margin-bottom: 2px;">üåæ</div>\n`;
        content += `      <div style="color: #d97706; font-weight: bold; font-size: 14px;">${item.carbs}g</div>\n`;
        content += `      <div style="color: #f59e0b; font-size: 9px; text-transform: uppercase; font-weight: 600;">CARBS</div>\n`;
        content += `    </div>\n`;
        content += `    <div style="text-align: center; padding: 8px; background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(237, 233, 254, 0.9)); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border-radius: 12px; border: 1px solid rgba(196, 181, 253, 0.3); box-shadow: 0 4px 16px rgba(168, 85, 247, 0.06), inset 0 1px 0 rgba(255,255,255,0.8);">\n`;
        content += `      <div style="font-size: 16px; margin-bottom: 2px;">ü•ë</div>\n`;
        content += `      <div style="color: #7c3aed; font-weight: bold; font-size: 14px;">${item.fat}g</div>\n`;
        content += `      <div style="color: #8b5cf6; font-size: 9px; text-transform: uppercase; font-weight: 600;">FAT</div>\n`;
        content += `    </div>\n`;
        content += `  </div>\n`;
        content += `</div>\n\n`;
      }
    }
    
    return content;
  }

  private getEffectiveTheme(): 'light' | 'dark' {
    if (this.settings.displayTheme === 'auto') {
      // Auto-detect Obsidian's theme
      return document.body.classList.contains('theme-dark') ? 'dark' : 'light';
    }
    return this.settings.displayTheme as 'light' | 'dark';
  }

  private generateSimpleLayout(foodItems: FoodItem[]): string {
    let content = '';
    const isDark = this.getEffectiveTheme() === 'dark';
    
    for (const item of foodItems) {
      const emoji = this.getFoodEmoji(item.food);
      const entryId = `entry-${item.food.replace(/[^a-zA-Z0-9]/g, '-')}-${item.quantity.replace(/[^a-zA-Z0-9]/g, '-')}-${item.calories}`;
      
      // Time formatting
      let timeDisplay = '';
      if (item.timestamp) {
        const time = new Date(item.timestamp).toLocaleTimeString('en-US', { 
          hour: '2-digit', 
          minute: '2-digit' 
        });
        timeDisplay = ` üïê ${time}`;
      }
      
      // Clean theme-based styling
      const styles = isDark ? {
        background: 'linear-gradient(135deg, rgba(51, 65, 85, 0.6), rgba(30, 41, 59, 0.4))',
        borderColor: 'rgba(139, 92, 246, 0.6)',
        textColor: '#f8fafc',
        subtleColor: '#cbd5e1',
        quantityBg: 'rgba(255, 255, 255, 0.1)',
        shadow: '0 4px 16px rgba(0, 0, 0, 0.3)',
        editBtnBg: 'rgba(255, 255, 255, 0.08)',
        editBtnBorder: 'rgba(255, 255, 255, 0.15)'
      } : {
        background: 'linear-gradient(135deg, rgba(255, 255, 255, 0.8), rgba(248, 250, 252, 0.6))',
        borderColor: 'rgba(139, 92, 246, 0.5)',
        textColor: '#0f172a',
        subtleColor: '#475569',
        quantityBg: 'rgba(0, 0, 0, 0.05)',
        shadow: '0 4px 16px rgba(0, 0, 0, 0.08)',
        editBtnBg: 'rgba(0, 0, 0, 0.04)',
        editBtnBorder: 'rgba(0, 0, 0, 0.08)'
      };
      
      // Main container
      content += `<div id="${entryId}" class="nutrition-food-entry-simple ${entryId}" data-food="${item.food.replace(/"/g, '&quot;')}" data-quantity="${item.quantity.replace(/"/g, '&quot;')}" data-calories="${item.calories}" data-protein="${item.protein}" data-carbs="${item.carbs}" data-fat="${item.fat}" style="margin: 12px 0; padding: 16px 20px; background: ${styles.background}; border-left: 4px solid ${styles.borderColor}; border-radius: 0 12px 12px 0; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); box-shadow: ${styles.shadow}; overflow: hidden;">\n\n`;
      
      // Header with food name and edit button
      content += `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">\n`;
      content += `<h3 style="margin: 0; color: ${styles.textColor}; font-size: 18px; font-weight: 600;">${emoji} ${item.food}</h3>\n`;
      content += `<button class="nutrition-edit-btn" data-food="${item.food.replace(/"/g, '&quot;')}" data-quantity="${item.quantity.replace(/"/g, '&quot;')}" data-calories="${item.calories}" data-protein="${item.protein}" data-carbs="${item.carbs}" data-fat="${item.fat}" style="background: ${styles.editBtnBg}; border: 1px solid ${styles.editBtnBorder}; color: ${styles.subtleColor}; cursor: pointer; font-size: 12px; padding: 4px 8px; border-radius: 6px; transition: all 0.2s ease; opacity: 0.8;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.8'">‚úèÔ∏è</button>\n`;
      content += `</div>\n\n`;
      
      // Quantity and time
      content += `<div style="color: ${styles.textColor}; font-weight: 500; margin-bottom: 10px;">\n`;
      content += `<span style="background: ${styles.quantityBg}; padding: 2px 8px; border-radius: 6px; font-size: 14px;">${item.quantity}</span>${timeDisplay}\n`;
      content += `</div>\n\n`;
      
      // Nutrition info
      content += `<div style="color: ${styles.subtleColor}; font-size: 14px; line-height: 1.5;">\n`;
      content += `üî• <span style="color: ${isDark ? '#f87171' : '#dc2626'}; font-weight: 600;">${item.calories} kcal</span> „Éª `;
      content += `üí™ <span style="color: ${isDark ? '#4ade80' : '#16a34a'}; font-weight: 600;">${item.protein}g protein</span> „Éª `;
      content += `üåæ <span style="color: ${isDark ? '#fbbf24' : '#d97706'}; font-weight: 600;">${item.carbs}g carbs</span> „Éª `;
      content += `ü•ë <span style="color: ${isDark ? '#a78bfa' : '#7c3aed'}; font-weight: 600;">${item.fat}g fat</span>\n`;
      content += `</div>\n\n`;
      
      content += `</div>\n\n`;
    }
    
    return content;
  }

  private async generateDailySummary(totals: NutritionData): Promise<string> {
    const goals = this.settings.nutritionGoals;
    const isDark = this.getEffectiveTheme() === 'dark';
    
    let summary = '## üìä Daily Summary\n\n';
    
    // Create glassy card wrapper similar to food cards but lighter
    const cardStyles = isDark ? {
      background: 'linear-gradient(135deg, rgba(51, 65, 85, 0.6), rgba(30, 41, 59, 0.5))',
      border: '1px solid rgba(148, 163, 184, 0.25)',
      shadow: '0 8px 32px rgba(0,0,0,0.2), inset 0 1px 0 rgba(255,255,255,0.08)',
      textColor: '#f8fafc',
      subtleColor: '#cbd5e1',
      footerColor: '#94a3b8'
    } : {
      background: 'linear-gradient(135deg, rgb(240 240 240 / 80%), rgba(248, 250, 252, 0.7))',
      border: '1px solid rgba(255, 255, 255, 0.7)',
      shadow: '0 8px 32px rgba(0,0,0,0.06), inset 0 1px 0 rgba(255,255,255,0.9)',
      textColor: '#0f172a',
      subtleColor: '#475569',
      footerColor: '#64748b'
    };
    
    // Create the entire card as a single-line HTML structure (like food item cards)
    const nutrients = [
      { name: 'Calories', emoji: 'üî•', current: totals.calories, goal: goals.calories, unit: 'kcal' },
      { name: 'Protein', emoji: 'üí™', current: totals.protein, goal: goals.protein, unit: 'g' },
      { name: 'Carbs', emoji: 'üåæ', current: totals.carbs, goal: goals.carbs, unit: 'g' },
      { name: 'Fat', emoji: 'ü•ë', current: totals.fat, goal: goals.fat, unit: 'g' }
    ];
    
    // Overall status
    const overallProgress = Math.round((
      this.calculatePercentage(totals.calories, goals.calories) +
      this.calculatePercentage(totals.protein, goals.protein) +
      this.calculatePercentage(totals.carbs, goals.carbs) +
      this.calculatePercentage(totals.fat, goals.fat)
    ) / 4);
    
    // Generate nutrition rows
    let nutritionRows = '';
    if (this.settings.progressBarStyle === 'modern-bars') {
      // For modern bars, get the progress bars but strip newlines and fix bold formatting
      nutritionRows = this.generateModernProgressBars(totals, goals).replace(/\n+/g, '').replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    } else {
      for (const nutrient of nutrients) {
        const percentage = this.calculatePercentage(nutrient.current, nutrient.goal);
        const progressBar = this.settings.progressBarStyle === 'percentage-only' ? '' : this.getProgressBar(nutrient.current, nutrient.goal);
        
        nutritionRows += `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; padding: 8px 0;"><span style="color: ${cardStyles.textColor}; font-weight: 500; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">${nutrient.emoji} ${nutrient.name}:</span><span style="color: ${cardStyles.subtleColor}; font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace; font-size: 13px; font-weight: 400;">${Math.round(nutrient.current)} / ${nutrient.goal} ${nutrient.unit}</span><span style="color: ${cardStyles.textColor}; font-weight: 400; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">${progressBar} ${percentage}%</span></div>`;
      }
    }
    
    // Build the entire card as a single line (like food item cards)
    // Create ultra-subtle glassy overall progress section
    const progressBg = isDark 
      ? 'rgba(255, 255, 255, 0.08)'
      : 'linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(248, 248, 248, 0.15))';
    
    const progressBorder = isDark 
      ? 'rgba(255, 255, 255, 0.15)'
      : 'rgba(255, 255, 255, 0.25)';
    
    // Enhanced divider with dark grey/resin color
    const dividerStyle = isDark 
      ? 'background: linear-gradient(90deg, transparent, rgba(60, 60, 60, 0.8), transparent); height: 1px; border: none;'
      : 'background: linear-gradient(90deg, transparent, rgba(80, 80, 80, 0.4), transparent); height: 1px; border: none;';
    
    // Enhanced overall progress border with gradient
    const enhancedProgressBorder = isDark 
      ? 'background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(148, 163, 184, 0.15)); padding: 1px; border-radius: 13px;'
      : 'background: linear-gradient(135deg, rgba(0, 0, 0, 0.15), rgba(100, 100, 100, 0.1)); padding: 1px; border-radius: 13px;';
    
    summary += `<div style="background: ${cardStyles.background}; backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); border-radius: 16px; padding: 20px; margin: 12px 0; box-shadow: ${cardStyles.shadow}; border: ${cardStyles.border};"><h3 style="color: ${cardStyles.textColor}; margin-top: 0; margin-bottom: 16px; font-size: 18px; font-weight: 500; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; letter-spacing: -0.5px;">üéØ Totals vs Goals</h3><div style="${dividerStyle} margin-bottom: 16px;"></div>${nutritionRows}<div style="${enhancedProgressBorder} text-align: center; margin: 32px 0 0;"><div style="background: ${progressBg}; border-radius: 12px; padding: 12px;"><h3 style="color: ${cardStyles.textColor}; margin: 0; font-size: 20px; font-weight: 500; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; letter-spacing: -0.8px;">${this.getOverallStatusEmoji(overallProgress)} Overall Progress: ${overallProgress}%</h3></div></div></div>\n\n`;
    
    return summary;
  }

  private generateModernProgressBars(totals: NutritionData, goals: any): string {
    let content = '';
    const isDark = this.getEffectiveTheme() === 'dark';
    
    const nutrients = [
      { name: 'Calories', emoji: 'üî•', current: totals.calories, goal: goals.calories, unit: 'kcal' },
      { name: 'Protein', emoji: 'üí™', current: totals.protein, goal: goals.protein, unit: 'g' },
      { name: 'Carbs', emoji: 'üåæ', current: totals.carbs, goal: goals.carbs, unit: 'g' },
      { name: 'Fat', emoji: 'ü•ë', current: totals.fat, goal: goals.fat, unit: 'g' }
    ];
    
    for (const nutrient of nutrients) {
      const percentage = this.calculatePercentage(nutrient.current, nutrient.goal);
      const { gradient, textColor, borderColor } = this.getProgressGradient(percentage, isDark);
      
      // Ultra-subtle glassy track background with enhanced borders
      const trackBg = isDark 
        ? 'linear-gradient(135deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.01))'
        : 'linear-gradient(135deg, rgba(0, 0, 0, 0.02), rgba(0, 0, 0, 0.01))';
      
      const trackBorder = isDark 
        ? 'rgba(255, 255, 255, 0.12)' 
        : 'rgba(0, 0, 0, 0.12)';
      
      const trackShadow = isDark 
        ? 'inset 0 1px 2px rgba(0, 0, 0, 0.1), 0 1px 0 rgba(255, 255, 255, 0.03)'
        : 'inset 0 1px 2px rgba(0, 0, 0, 0.06), 0 1px 0 rgba(255, 255, 255, 0.8)';
      
      content += `<span style="color: ${isDark ? '#e0e0e0' : '#333'}; font-weight: 500; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; font-size: 15px; letter-spacing: -0.3px;">${nutrient.emoji} ${nutrient.name}:</span> <span style="color: ${isDark ? '#a0a0a0' : '#666'}; font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace; font-size: 13px; font-weight: 400;">${Math.round(nutrient.current)} / ${nutrient.goal} ${nutrient.unit}</span> `;
      content += `<span style="color: ${textColor}; font-weight: 500; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; font-size: 14px;">(${percentage}%)</span>\n`;
      
      // Ultra-minimalistic glassy progress bar with enhanced visibility
      content += `<div style="width: 100%; background: ${trackBg}; border: 1px solid ${trackBorder}; border-radius: 10px; height: 16px; margin: 6px 0 12px 0; padding: 2px; backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px); box-shadow: ${trackShadow};">\n`;
      content += `  <div style="width: ${Math.min(percentage, 100)}%; background: ${gradient}; height: 100%; border-radius: 8px; border: 1px solid ${borderColor}; transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1); position: relative; overflow: hidden; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);">\n`;
      
      // Enhanced glass shine effect with theme adaptation
      if (percentage > 0) {
        const shineOpacity = isDark ? 0.06 : 0.12;
        const shineFade = shineOpacity * 0.3;
        content += `    <div style="position: absolute; top: 0; left: 0; right: 0; height: 50%; background: linear-gradient(180deg, rgba(255,255,255,${shineOpacity}) 0%, rgba(255,255,255,${shineFade}) 70%, transparent 100%); border-radius: 8px 8px 0 0;"></div>\n`;
        
        // Subtle inner glow
        const glowOpacity = isDark ? 0.03 : 0.04;
        content += `    <div style="position: absolute; inset: 0; border-radius: 8px; box-shadow: inset 0 0 8px rgba(255,255,255,${glowOpacity});"></div>\n`;
      }
      
      content += `  </div>\n`;
      content += `</div>\n\n`;
    }
    
    return content;
  }

  private getPercentageColor(percentage: number): string {
    const isDark = this.getEffectiveTheme() === 'dark';
    
    if (percentage <= 30) {
      return isDark ? '#ef4444' : '#dc2626'; // Red
    } else if (percentage <= 70) {
      return isDark ? '#f59e0b' : '#d97706'; // Orange
    } else {
      return isDark ? '#10b981' : '#059669'; // Green
    }
  }

  private getProgressGradient(percentage: number, isDark: boolean): { gradient: string, textColor: string, borderColor: string } {
    // Smooth, muted color transitions: Red (0%) ‚Üí Orange (50%) ‚Üí Green (100%)
    // Cap at 100% to prevent color changes beyond completion
    const cappedPercentage = Math.min(percentage, 100);
    let r, g, b;
    
    if (isDark) {
      // Dark theme: Natural, muted colors with good visibility
      if (cappedPercentage <= 50) {
        // Red to Yellow transition (0% to 50%) - natural warm tones
        const factor = cappedPercentage / 50;
        r = Math.round(200 + (220 - 200) * factor); // 200 (natural red) to 220 (natural yellow)
        g = Math.round(90 + (180 - 90) * factor);   // 90 (natural red) to 180 (natural yellow)
        b = Math.round(90 + (85 - 90) * factor);    // 90 (natural red) to 85 (natural yellow)
      } else {
        // Yellow to Green transition (50% to 100%) - natural warm to cool
        const factor = (cappedPercentage - 50) / 50;
        r = Math.round(220 - (220 - 110) * factor); // 220 (natural yellow) to 110 (natural green)
        g = Math.round(180 - (180 - 170) * factor); // 180 (natural yellow) to 170 (natural green)
        b = Math.round(85 + (110 - 85) * factor);   // 85 (natural yellow) to 110 (natural green)
      }
    } else {
      // Light theme: Natural, muted colors - traffic light progression
      if (cappedPercentage <= 50) {
        // Red to Yellow transition (0% to 50%) - natural coral to warm yellow
        const factor = cappedPercentage / 50;
        r = Math.round(190 + (210 - 190) * factor); // 190 (natural coral) to 210 (natural yellow)
        g = Math.round(110 + (175 - 110) * factor); // 110 (natural coral) to 175 (natural yellow)
        b = Math.round(110 + (90 - 110) * factor);  // 110 (natural coral) to 90 (natural yellow)
      } else {
        // Yellow to Green transition (50% to 100%) - natural yellow to sage
        const factor = (cappedPercentage - 50) / 50;
        r = Math.round(210 - (210 - 130) * factor); // 210 (natural yellow) to 130 (natural sage)
        g = Math.round(175 - (175 - 150) * factor); // 175 (natural yellow) to 150 (natural sage)
        b = Math.round(90 + (120 - 90) * factor);   // 90 (natural yellow) to 120 (natural sage)
      }
    }
    
    // Create glassy gradients with enhanced visibility for dark theme
    const baseOpacity = isDark ? 0.45 : 0.3;
    const primaryColor = `rgba(${r}, ${g}, ${b}, ${baseOpacity})`;
    const secondaryColor = `rgba(${r}, ${g}, ${b}, ${baseOpacity * 0.6})`;
    
    // Multi-stop gradient for more sophisticated glass effect
    const gradient = `linear-gradient(135deg, ${primaryColor} 0%, rgba(${r}, ${g}, ${b}, ${baseOpacity * 0.8}) 50%, ${secondaryColor} 100%)`;
    
    // Enhanced border visibility for dark theme
    const borderOpacity = isDark ? 0.6 : 0.45;
    const borderColor = `rgba(${r}, ${g}, ${b}, ${borderOpacity})`;
    
    // Text color - enhanced visibility for dark theme
    const textOpacity = isDark ? 0.95 : 0.75;
    const textColor = `rgba(${Math.round(r * 0.9)}, ${Math.round(g * 0.9)}, ${Math.round(b * 0.9)}, ${textOpacity})`;
    
    return { gradient, textColor, borderColor };
  }

  private async recalculateTotals(content: string): Promise<string> {
    // Extract all nutrition values from the content
    const foodItems = this.extractFoodItemsFromContent(content);
    const totals = this.calculateTotals(foodItems);
    
    // Generate the new summary
    const newSummary = await this.generateDailySummary(totals);
    
    // Check if there's already a summary to replace (including any existing footer)
    const summaryRegex = /## üìä Daily Summary[\s\S]*?(?=\n---\n\n\*‚ú® Generated by|$)/;
    const footerRegex = /\n---\n\n\*‚ú® Generated by.*?Plugin\*\n*$/;
    
    if (summaryRegex.test(content)) {
      // Replace existing summary and footer
      let updatedContent = content.replace(summaryRegex, newSummary.trim());
      // Remove any existing footer
      updatedContent = updatedContent.replace(footerRegex, '');
      // Add new footer
      return updatedContent + '\n---\n\n*‚ú® Generated by AI Nutrition Tracker Plugin*\n';
    } else {
      // Add new summary and footer at the end
      let updatedContent = content;
      // Remove any existing footer first
      updatedContent = updatedContent.replace(footerRegex, '');
      return updatedContent + '\n' + newSummary.trim() + '\n---\n\n*‚ú® Generated by AI Nutrition Tracker Plugin*\n';
    }
  }

  private extractFoodItemsFromContent(content: string): FoodItem[] {
    const items: FoodItem[] = [];
    
    // Try simple layout first (most common - data-food, data-quantity, etc.)
    const simpleRegex = /class="nutrition-food-entry-simple[^"]*"[^>]*data-food="([^"]*)"[^>]*data-quantity="([^"]*)"[^>]*data-calories="([^"]*)"[^>]*data-protein="([^"]*)"[^>]*data-carbs="([^"]*)"[^>]*data-fat="([^"]*)"/g;
    
    // Try card layout (data-ntr-food, data-ntr-quantity, etc.)
    const cardAttributeRegex = /<div[^>]*data-ntr-food="([^"]*)"[^>]*data-ntr-quantity="([^"]*)"[^>]*data-ntr-calories="([\d.]+)"[^>]*data-ntr-protein="([\d.]+)"[^>]*data-ntr-carbs="([\d.]+)"[^>]*data-ntr-fat="([\d.]+)"[^>]*>/g;
    
    // Extract from old HTML card layouts (fallback)
    const htmlCardRegex = /<div style="background: linear-gradient\(135deg,[^"]+\)"[\s\S]*?<h3[^>]*>([^<]+)<\/h3>[\s\S]*?üìè ([^<]+)[\s\S]*?<div style="color: [^"]+; font-weight: bold; font-size: 14px;">([\d.]+)<\/div>[\s\S]*?<div style="color: [^"]+; font-weight: bold; font-size: 14px;">([\d.]+)g<\/div>[\s\S]*?<div style="color: [^"]+; font-weight: bold; font-size: 14px;">([\d.]+)g<\/div>[\s\S]*?<div style="color: [^"]+; font-weight: bold; font-size: 14px;">([\d.]+)g<\/div>/g;
    
    // Try simple layout first (most reliable for new entries)
    let match;
    while ((match = simpleRegex.exec(content)) !== null) {
      items.push({
        food: match[1].replace(/&quot;/g, '"'),
        quantity: match[2].replace(/&quot;/g, '"'),
        calories: parseFloat(match[3]),
        protein: parseFloat(match[4]),
        carbs: parseFloat(match[5]),
        fat: parseFloat(match[6])
      });
    }
    
    // If no simple layout entries found, try card layout
    if (items.length === 0) {
      while ((match = cardAttributeRegex.exec(content)) !== null) {
        // Extract all nutrition data from card data attributes
        const food = match[1].replace(/&quot;/g, '"');
        const quantity = match[2].replace(/&quot;/g, '"');
        const calories = parseFloat(match[3]);
        const protein = parseFloat(match[4]);
        const carbs = parseFloat(match[5]);
        const fat = parseFloat(match[6]);
        
        items.push({
          food,
          quantity,
          calories,
          protein,
          carbs,
          fat
        });
      }
    }
    
    // If still no items found, try old HTML card pattern
    if (items.length === 0) {
      while ((match = htmlCardRegex.exec(content)) !== null) {
        items.push({
          food: match[1].trim(),
          quantity: match[2].trim(),
          calories: parseFloat(match[3]),
          protein: parseFloat(match[4]),
          carbs: parseFloat(match[5]),
          fat: parseFloat(match[6])
        });
      }
    }
    
    return items;
  }

  private calculateTotals(foodItems: FoodItem[]): NutritionData {
    return foodItems.reduce((totals, item) => ({
      calories: totals.calories + (item.calories || 0),
      protein: totals.protein + (item.protein || 0),
      carbs: totals.carbs + (item.carbs || 0),
      fat: totals.fat + (item.fat || 0)
    }), { calories: 0, protein: 0, carbs: 0, fat: 0 });
  }

  private calculatePercentage(current: number, goal: number): number {
    if (goal === 0) return 0;
    return Math.round((current / goal) * 100);
  }

  private getTodayString(): string {
    const today = new Date();
    return today.toISOString().split('T')[0]; // YYYY-MM-DD
  }

  private async ensureDirectoryExists(path: string): Promise<void> {
    const dirs = path.split('/');
    let currentPath = '';
    
    for (const dir of dirs) {
      currentPath = currentPath ? `${currentPath}/${dir}` : dir;
      
      const exists = this.vault.getAbstractFileByPath(currentPath);
      if (!exists) {
        await this.vault.createFolder(currentPath);
      }
    }
  }

  async saveImage(imageFile: File): Promise<string> {
    try {
      await this.ensureDirectoryExists(this.settings.imageStoragePath);
      
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const extension = imageFile.name.split('.').pop() || 'jpg';
      const filename = `food-image-${timestamp}.${extension}`;
      const imagePath = `${this.settings.imageStoragePath}/${filename}`;
      
      // Convert File to ArrayBuffer
      const arrayBuffer = await imageFile.arrayBuffer();
      await this.vault.createBinary(imagePath, arrayBuffer);
      
      return imagePath;
    } catch (error) {
      console.error('Error saving image:', error);
      throw new Error(`Failed to save image: ${error.message}`);
    }
  }

  private getFoodEmoji(foodName: string): string {
    const food = foodName.toLowerCase();
    
    // Fruits
    if (food.includes('apple')) return 'üçé';
    if (food.includes('banana')) return 'üçå';
    if (food.includes('orange')) return 'üçä';
    if (food.includes('strawberry') || food.includes('berry')) return 'üçì';
    if (food.includes('grape')) return 'üçá';
    if (food.includes('watermelon') || food.includes('melon')) return 'üçâ';
    if (food.includes('pineapple')) return 'üçç';
    if (food.includes('mango')) return 'ü•≠';
    if (food.includes('peach')) return 'üçë';
    if (food.includes('cherry')) return 'üçí';
    
    // Vegetables
    if (food.includes('tomato')) return 'üçÖ';
    if (food.includes('eggplant')) return 'üçÜ';
    if (food.includes('avocado')) return 'ü•ë';
    if (food.includes('broccoli')) return 'ü•¶';
    if (food.includes('cucumber')) return 'ü•í';
    if (food.includes('pepper') || food.includes('bell pepper')) return 'ü´ë';
    if (food.includes('carrot')) return 'ü•ï';
    if (food.includes('corn')) return 'üåΩ';
    if (food.includes('lettuce') || food.includes('leafy') || food.includes('salad')) return 'ü•¨';
    if (food.includes('spinach')) return 'ü•¨';
    if (food.includes('potato')) return 'ü•î';
    if (food.includes('onion')) return 'üßÖ';
    if (food.includes('garlic')) return 'üßÑ';
    
    // Grains & Bread
    if (food.includes('bread') || food.includes('toast')) return 'üçû';
    if (food.includes('rice')) return 'üçö';
    if (food.includes('pasta') || food.includes('spaghetti') || food.includes('noodle')) return 'üçù';
    if (food.includes('pizza')) return 'üçï';
    if (food.includes('bagel')) return 'ü•Ø';
    if (food.includes('pretzel')) return 'ü•®';
    if (food.includes('croissant')) return 'ü•ê';
    if (food.includes('waffle')) return 'üßá';
    if (food.includes('pancake')) return 'ü•û';
    if (food.includes('cereal') || food.includes('oatmeal') || food.includes('oats')) return 'ü•£';
    
    // Proteins
    if (food.includes('chicken')) return 'üçó';
    if (food.includes('meat') || food.includes('steak') || food.includes('beef')) return 'ü•©';
    if (food.includes('bacon')) return 'ü•ì';
    if (food.includes('fish') || food.includes('salmon') || food.includes('tuna')) return 'üêü';
    if (food.includes('shrimp') || food.includes('prawn')) return 'üç§';
    if (food.includes('egg')) return 'ü•ö';
    if (food.includes('cheese')) return 'üßÄ';
    
    // Dairy & Drinks
    if (food.includes('milk')) return 'ü•õ';
    if (food.includes('yogurt') || food.includes('yoghurt')) return 'üç¶';
    if (food.includes('coffee')) return '‚òï';
    if (food.includes('tea')) return 'üçµ';
    if (food.includes('water')) return 'üíß';
    if (food.includes('juice')) return 'üßÉ';
    if (food.includes('smoothie')) return 'ü•§';
    
    // Snacks & Sweets
    if (food.includes('chocolate') || food.includes('cocoa')) return 'üç´';
    if (food.includes('cookie') || food.includes('biscuit')) return 'üç™';
    if (food.includes('cake')) return 'üç∞';
    if (food.includes('donut') || food.includes('doughnut')) return 'üç©';
    if (food.includes('ice cream')) return 'üç®';
    if (food.includes('candy')) return 'üç¨';
    if (food.includes('honey')) return 'üçØ';
    
    // Nuts & Seeds
    if (food.includes('nut') || food.includes('almond') || food.includes('walnut')) return 'ü•ú';
    if (food.includes('coconut')) return 'ü••';
    
    // Legumes
    if (food.includes('bean') || food.includes('lentil')) return 'ü´ò';
    
    // Prepared foods
    if (food.includes('soup')) return 'üç≤';
    if (food.includes('stew')) return 'üç≤';
    if (food.includes('curry')) return 'üçõ';
    if (food.includes('sandwich') || food.includes('burger')) return 'ü•™';
    if (food.includes('taco')) return 'üåÆ';
    if (food.includes('burrito')) return 'üåØ';
    if (food.includes('sushi')) return 'üç£';
    if (food.includes('ramen')) return 'üçú';
    
    // Supplements
    if (food.includes('protein powder') || food.includes('whey')) return 'ü•§';
    if (food.includes('vitamin') || food.includes('supplement')) return 'üíä';
    
    // Default
    return 'üçΩÔ∏è';
  }

  private getProgressBar(current: number, goal: number): string {
    const percentage = this.calculatePercentage(current, goal);
    const filledBlocks = Math.min(10, Math.round(percentage / 10));
    const emptyBlocks = 10 - filledBlocks;
    const isDark = this.getEffectiveTheme() === 'dark';
    
    let bar = '';
    
    // Enhanced emoji selection with smooth transitions
    for (let i = 0; i < 10; i++) {
      const blockPercentage = ((i + 1) * 10);
      
      if (blockPercentage <= percentage) {
        // This block is filled - choose color based on overall percentage
        if (percentage >= 90) {
          bar += 'üü¢'; // Bright green for excellent progress
        } else if (percentage >= 70) {
          bar += i < 7 ? 'üü¢' : 'üü°'; // Mix of green and yellow
        } else if (percentage >= 50) {
          bar += i < 5 ? 'üü†' : 'üü°'; // Mix of orange and yellow  
        } else if (percentage >= 30) {
          bar += i < 3 ? 'üî¥' : 'üü†'; // Mix of red and orange
        } else {
          bar += 'üî¥'; // Red for low progress
        }
      } else {
        // Empty block - use theme-appropriate empty indicator
        bar += isDark ? '‚ö´' : '‚ö™';
      }
    }
    
    return bar;
  }

  private getOverallStatusEmoji(percentage: number): string {
    if (percentage >= 95) return 'üèÜ'; // Trophy for exceptional achievement
    if (percentage >= 90) return 'üéâ'; // Party for great progress
    if (percentage >= 80) return 'üî•'; // Fire for strong progress
    if (percentage >= 70) return 'üí™'; // Muscle for good progress
    if (percentage >= 60) return 'üìà'; // Chart for steady progress
    if (percentage >= 50) return '‚ö°'; // Lightning for halfway there
    if (percentage >= 30) return 'üå±'; // Seedling for growing progress
    if (percentage >= 10) return 'üèÉ‚Äç‚ôÇÔ∏è'; // Runner for getting started
    return 'üåü'; // Star for motivation to begin
  }
} 