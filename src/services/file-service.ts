import { TFile, Vault, Notice, TAbstractFile } from 'obsidian';
import { FoodItem, NutritionData, Meal } from '../types/nutrition';
import { PluginSettings } from '../types/settings';
import { LLMService } from './llm-service';

export class FileService {
  private llmService: LLMService;
  
  constructor(private vault: Vault, private settings: PluginSettings) {
    this.llmService = new LLMService(settings);
    console.log('FileService initialized with settings:', settings);
    console.log('Meal storage path:', settings.mealStoragePath);
  }

  async createOrUpdateFoodLog(foodItems: FoodItem[], replaceEntry?: { food: string, quantity: string, calories: number, protein: number, carbs: number, fat: number }): Promise<void> {
    const today = this.getTodayString();
    const logPath = `${this.settings.logStoragePath}/${today}.md`;
    
    try {
      // Ensure the directory exists
      await this.ensureDirectoryExists(this.settings.logStoragePath);
      
      // Check if file already exists
      const existingFile = this.vault.getAbstractFileByPath(logPath);
      
      if (existingFile instanceof TFile) {
        if (replaceEntry) {
          // Replace existing entry
          await this.replaceInExistingLog(existingFile, foodItems, replaceEntry);
        } else {
          // Append to existing file
          await this.appendToExistingLog(existingFile, foodItems);
        }
      } else {
        // Create new file
        await this.createNewFoodLog(logPath, foodItems);
      }
      
      if (replaceEntry) {
        new Notice(`‚úèÔ∏è Food entry replaced in: ${today}.md`);
      } else {
        new Notice(`Food log updated: ${today}.md`);
      }
    } catch (error) {
      console.error('Error creating/updating food log:', error);
      throw new Error(`Failed to save food log: ${error.message}`);
    }
  }

  private async createNewFoodLog(path: string, foodItems: FoodItem[]): Promise<void> {
    const content = await this.generateFoodLogContent(foodItems, true);
    await this.vault.create(path, content);
  }

  private async appendToExistingLog(file: TFile, foodItems: FoodItem[]): Promise<void> {
    const existingContent = await this.vault.read(file);
    const newEntries = await this.generateFoodLogContent(foodItems, false);
    
    // Find the position to insert new entries (before the daily summary)
    const summaryRegex = /## üìä Daily Summary[\s\S]*$/;
    const match = existingContent.match(summaryRegex);
    
    if (match) {
      // Remove the existing summary and insert new entries
      const beforeSummary = existingContent.substring(0, match.index);
      const updatedContent = beforeSummary + newEntries;
      
      // Recalculate totals (this will add the new summary)
      const finalContent = await this.recalculateTotals(updatedContent);
      await this.vault.modify(file, finalContent);
    } else {
      // No summary found, just append new entries and add summary
      const updatedContent = existingContent + '\n' + newEntries;
      const allFoodItems = this.extractFoodItemsFromContent(updatedContent);
      const totals = this.calculateTotals(allFoodItems);
      const summary = await this.generateDailySummary(totals);
      const finalContent = updatedContent + '\n' + summary + '\n---\n\n*‚ú® Generated by AI Nutrition Tracker Plugin*\n';
      await this.vault.modify(file, finalContent);
    }
  }

  private async replaceInExistingLog(file: TFile, newFoodItems: FoodItem[], originalEntry: { food: string, quantity: string, calories: number, protein: number, carbs: number, fat: number }): Promise<void> {
    const existingContent = await this.vault.read(file);
    
    // Find and replace the card in its original position
    const replacement = this.replaceCardInPosition(existingContent, originalEntry, newFoodItems);
    if (replacement.success) {
      console.log('Successfully replaced entry in original position');
      // Recalculate totals and update summary
      const finalContent = await this.recalculateTotals(replacement.content);
      await this.vault.modify(file, finalContent);
    } else {
      console.warn('Original entry not found for replacement, falling back to append');
      // Fallback to the old append logic
      await this.appendToExistingLog(file, newFoodItems);
    }
  }

  private replaceCardInPosition(content: string, originalEntry: { food: string, quantity: string, calories: number, protein: number, carbs: number, fat: number }, newFoodItems: FoodItem[]): { success: boolean, content: string } {
    // Find the start of the card using data attributes
    const escapedFood = originalEntry.food.replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/"/g, '&quot;');
    const escapedQuantity = originalEntry.quantity.replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/"/g, '&quot;');
    
    const cardPosition = this.findCardPosition(content, escapedFood, escapedQuantity, originalEntry.calories);
    if (!cardPosition.success) {
      return { success: false, content };
    }
    
    // Generate the new card content
    const newCardContent = this.generateCardLayout(newFoodItems);
    
    // Replace the old card with the new card at the exact position
    const beforeCard = content.substring(0, cardPosition.startIndex);
    const afterCard = content.substring(cardPosition.endIndex);
    
    // Clean up any extra whitespace and insert new card
    const cleanedAfter = afterCard.replace(/^\s*\n\s*/, '\n');
    const updatedContent = beforeCard + newCardContent.trim() + cleanedAfter;
    
    return { success: true, content: updatedContent };
  }

  private findCardPosition(content: string, escapedFood: string, escapedQuantity: string, calories: number): { success: boolean, startIndex: number, endIndex: number } {
    // Look for cards with complete nutrition data
    const startPattern = new RegExp(
      `<div[^>]*data-ntr-food="${escapedFood}"[^>]*data-ntr-quantity="${escapedQuantity}"[^>]*data-ntr-calories="${calories}"[^>]*data-ntr-protein="[^"]*"[^>]*data-ntr-carbs="[^"]*"[^>]*data-ntr-fat="[^"]*"[^>]*>`,
      'gi'
    );
    
    const startMatch = startPattern.exec(content);
    if (!startMatch) {
      // Try legacy pattern without complete nutrition data
      const legacyPattern = new RegExp(
        `<div[^>]*data-ntr-food="${escapedFood}"[^>]*data-ntr-quantity="${escapedQuantity}"[^>]*data-ntr-calories="${calories}"[^>]*>`,
        'gi'
      );
      const legacyMatch = legacyPattern.exec(content);
      if (!legacyMatch) {
        return { success: false, startIndex: -1, endIndex: -1 };
      }
      const cardBounds = this.findCardBounds(content, legacyMatch.index);
      return { success: cardBounds.success, startIndex: legacyMatch.index, endIndex: cardBounds.endIndex };
    }
    
    const cardBounds = this.findCardBounds(content, startMatch.index);
    return { success: cardBounds.success, startIndex: startMatch.index, endIndex: cardBounds.endIndex };
  }

  private findCardBounds(content: string, startIndex: number): { success: boolean, endIndex: number } {
    let divCount = 0;
    let i = startIndex;
    
    // Find the opening div
    while (i < content.length && content.charAt(i) !== '>') {
      i++;
    }
    i++; // Move past the >
    divCount = 1;
    
    // Count divs to find the matching closing div
    while (i < content.length && divCount > 0) {
      if (content.substring(i, i + 4) === '<div') {
        divCount++;
        i += 4;
      } else if (content.substring(i, i + 6) === '</div>') {
        divCount--;
        if (divCount === 0) {
          return { success: true, endIndex: i + 6 };
        }
        i += 6;
      } else {
        i++;
      }
    }
    
    return { success: false, endIndex: -1 };
  }

  private findAndReplaceCompleteCard(content: string, originalEntry: { food: string, quantity: string, calories: number, protein: number, carbs: number, fat: number }): { success: boolean, content: string } {
    // Find the start of the entry using data attributes
    const escapedFood = originalEntry.food.replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/"/g, '&quot;');
    const escapedQuantity = originalEntry.quantity.replace(/[.*+?^${}()|[\]\\]/g, '\\$&').replace(/"/g, '&quot;');
    
    // Try card layout attributes first (data-ntr-*) - new format with complete nutrition data
    const cardPattern = new RegExp(
      `<div[^>]*data-ntr-food="${escapedFood}"[^>]*data-ntr-quantity="${escapedQuantity}"[^>]*data-ntr-calories="${originalEntry.calories}"[^>]*data-ntr-protein="${originalEntry.protein}"[^>]*data-ntr-carbs="${originalEntry.carbs}"[^>]*data-ntr-fat="${originalEntry.fat}"[^>]*>`,
      'gi'
    );
    
    let startMatch = cardPattern.exec(content);
    if (!startMatch) {
      // Try legacy card pattern without complete nutrition data
      const legacyCardPattern = new RegExp(
        `<div[^>]*data-ntr-food="${escapedFood}"[^>]*data-ntr-quantity="${escapedQuantity}"[^>]*data-ntr-calories="${originalEntry.calories}"[^>]*>`,
        'gi'
      );
      startMatch = legacyCardPattern.exec(content);
    }
    
    if (!startMatch) {
      // Try simple layout attributes (data-*)
      const simplePattern = new RegExp(
        `<div[^>]*data-food="${escapedFood}"[^>]*data-quantity="${escapedQuantity}"[^>]*data-calories="${originalEntry.calories}"[^>]*>`,
        'gi'
      );
      startMatch = simplePattern.exec(content);
      
      if (!startMatch) {
        // Try alternative simple attribute order
        const simplePattern2 = new RegExp(
          `<div[^>]*data-calories="${originalEntry.calories}"[^>]*data-food="${escapedFood}"[^>]*data-quantity="${escapedQuantity}"[^>]*>`,
          'gi'
        );
        startMatch = simplePattern2.exec(content);
      }
    }
    
    if (!startMatch) {
      return { success: false, content };
    }
    
    return this.extractCompleteCard(content, startMatch.index);
  }

  private extractCompleteCard(content: string, startIndex: number): { success: boolean, content: string } {
    let divCount = 0;
    let i = startIndex;
    let cardStart = startIndex;
    let cardEnd = -1;
    
    // Find the opening div
    while (i < content.length && content.charAt(i) !== '>') {
      i++;
    }
    i++; // Move past the >
    divCount = 1;
    
    // Count divs to find the matching closing div
    while (i < content.length && divCount > 0) {
      if (content.substring(i, i + 4) === '<div') {
        divCount++;
        i += 4;
      } else if (content.substring(i, i + 6) === '</div>') {
        divCount--;
        if (divCount === 0) {
          cardEnd = i + 6;
          break;
        }
        i += 6;
      } else {
        i++;
      }
    }
    
    if (cardEnd === -1) {
      return { success: false, content };
    }
    
    // Extract the complete card and remove it
    const beforeCard = content.substring(0, cardStart);
    const afterCard = content.substring(cardEnd);
    
    // Clean up any extra whitespace/newlines
    const cleanedContent = beforeCard + afterCard.replace(/^\s*\n\s*/, '\n');
    
    return { success: true, content: cleanedContent };
  }

  private async generateFoodLogContent(foodItems: FoodItem[], isNewFile: boolean): Promise<string> {
    const today = this.getTodayString();
    const totals = this.calculateTotals(foodItems);
    
    let content = '';
    
    if (isNewFile) {
      content += `# üçΩÔ∏è Food Log ${today}\n\n`;
      content += `## ü•ó Today's Meals\n\n`;
    }
    
    // Generate food items based on layout style
    if (this.settings.layoutStyle === 'cards') {
      content += this.generateCardLayout(foodItems, 'foodlog');
    } else {
      content += this.generateSimpleLayout(foodItems, 'foodlog');
    }
    
    if (isNewFile) {
      content += await this.generateDailySummary(totals);
      content += '\n---\n\n';
      content += '*‚ú® Generated by AI Nutrition Tracker Plugin*\n';
    }
    
    return content;
  }

  private generateCardLayout(foodItems: FoodItem[], context?: 'meal' | 'foodlog'): string {
    let content = '';
    const isDarkTheme = this.getEffectiveTheme() === 'dark';
    
    for (const item of foodItems) {
      const emoji = item.emoji || 'üçΩÔ∏è';
      const timeStr = item.timestamp ? 
        new Date(item.timestamp).toLocaleTimeString('en-US', { 
          hour: '2-digit', 
          minute: '2-digit' 
        }) : '';
      
      // Add context to identify where the edit originated from
      const editContext = context || 'foodlog';
      
      if (isDarkTheme) {
        // Glassy dark theme card
        const entryId = `ntr-${Date.now()}-${Math.random().toString(36).substr(2, 6)}`;
        content += `\n<div id="${entryId}" data-ntr-food="${item.food.replace(/"/g, '&quot;')}" data-ntr-quantity="${item.quantity.replace(/"/g, '&quot;')}" data-ntr-calories="${item.calories}" data-ntr-protein="${item.protein}" data-ntr-carbs="${item.carbs}" data-ntr-fat="${item.fat}" style="background: linear-gradient(135deg, rgba(30, 41, 59, 0.75), rgba(51, 65, 85, 0.75)); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-radius: 16px; padding: 14px; margin: 10px 0; box-shadow: 0 8px 32px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.1); border: 1px solid rgba(148,163,184,0.2); position: relative; overflow: hidden;">\n`;
        content += `  <div style="display: flex; align-items: flex-start; justify-content: space-between; margin-bottom: 10px;">\n`;
        content += `    <div style="display: flex; align-items: center; flex: 1;">\n`;
        content += `      <span style="font-size: 32px; margin-right: 10px;">${emoji}</span>\n`;
        content += `      <div style="flex: 1;">\n`;
        content += `        <h3 style="color: #f8fafc; margin: 0; font-size: 16px; font-weight: 600;">${item.food}</h3>\n`;
        content += `        <div style="color: #94a3b8; font-size: 12px; margin-top: 2px;">üìè ${item.quantity}</div>\n`;
        if (timeStr) {
          content += `        <div style="color: #94a3b8; font-size: 10px; margin-top: 1px; opacity: 0.8;">üïê ${timeStr}</div>\n`;
        }
        content += `      </div>\n`;
        content += `    </div>\n`;
        content += `    <button class="nutrition-edit-btn" data-food="${item.food.replace(/"/g, '&quot;')}" data-quantity="${item.quantity.replace(/"/g, '&quot;')}" data-calories="${item.calories}" data-protein="${item.protein}" data-carbs="${item.carbs}" data-fat="${item.fat}" data-edit-context="${editContext}" style="background: linear-gradient(135deg, rgba(148,163,184,0.12), rgba(100,116,139,0.08)); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border: 1px solid rgba(148,163,184,0.25); border-radius: 8px; padding: 6px 10px; color: #cbd5e1; font-size: 10px; cursor: pointer; margin-left: 12px; box-shadow: 0 2px 8px rgba(148,163,184,0.1), inset 0 1px 0 rgba(255,255,255,0.1); flex-shrink: 0;">‚úèÔ∏è Edit</button>\n`;
        content += `  </div>\n`;
        content += `  <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px;">\n`;
        content += `    <div style="text-align: center; padding: 8px; background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(185, 28, 28, 0.1)); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border-radius: 12px; border: 1px solid rgba(239, 68, 68, 0.25); box-shadow: 0 4px 16px rgba(239, 68, 68, 0.1);">\n`;
        content += `      <div style="font-size: 16px; margin-bottom: 2px;">üî•</div>\n`;
        content += `      <div style="color: #fecaca; font-weight: bold; font-size: 14px;">${item.calories}</div>\n`;
        content += `      <div style="color: #f87171; font-size: 9px; text-transform: uppercase; font-weight: 500;">kcal</div>\n`;
        content += `    </div>\n`;
        content += `    <div style="text-align: center; padding: 8px; background: linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(22, 163, 74, 0.1)); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border-radius: 12px; border: 1px solid rgba(34, 197, 94, 0.25); box-shadow: 0 4px 16px rgba(34, 197, 94, 0.1);">\n`;
        content += `      <div style="font-size: 16px; margin-bottom: 2px;">üí™</div>\n`;
        content += `      <div style="color: #bbf7d0; font-weight: bold; font-size: 14px;">${item.protein}g</div>\n`;
        content += `      <div style="color: #86efac; font-size: 9px; text-transform: uppercase; font-weight: 500;">protein</div>\n`;
        content += `    </div>\n`;
        content += `    <div style="text-align: center; padding: 8px; background: linear-gradient(135deg, rgba(251, 191, 36, 0.2), rgba(217, 119, 6, 0.1)); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border-radius: 12px; border: 1px solid rgba(251, 191, 36, 0.25); box-shadow: 0 4px 16px rgba(251, 191, 36, 0.1);">\n`;
        content += `      <div style="font-size: 16px; margin-bottom: 2px;">üåæ</div>\n`;
        content += `      <div style="color: #fde68a; font-weight: bold; font-size: 14px;">${item.carbs}g</div>\n`;
        content += `      <div style="color: #fbbf24; font-size: 9px; text-transform: uppercase; font-weight: 500;">carbs</div>\n`;
        content += `    </div>\n`;
        content += `    <div style="text-align: center; padding: 8px; background: linear-gradient(135deg, rgba(168, 85, 247, 0.2), rgba(124, 58, 237, 0.1)); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border-radius: 12px; border: 1px solid rgba(168, 85, 247, 0.25); box-shadow: 0 4px 16px rgba(168, 85, 247, 0.1);">\n`;
        content += `      <div style="font-size: 16px; margin-bottom: 2px;">ü•ë</div>\n`;
        content += `      <div style="color: #ddd6fe; font-weight: bold; font-size: 14px;">${item.fat}g</div>\n`;
        content += `      <div style="color: #c4b5fd; font-size: 9px; text-transform: uppercase; font-weight: 500;">fat</div>\n`;
        content += `    </div>\n`;
        content += `  </div>\n`;
        content += `</div>\n\n`;
      } else {
        // Glassy light theme card
        const entryId = `ntr-${Date.now()}-${Math.random().toString(36).substr(2, 6)}`;
        content += `\n<div id="${entryId}" data-ntr-food="${item.food.replace(/"/g, '&quot;')}" data-ntr-quantity="${item.quantity.replace(/"/g, '&quot;')}" data-ntr-calories="${item.calories}" data-ntr-protein="${item.protein}" data-ntr-carbs="${item.carbs}" data-ntr-fat="${item.fat}" style="background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(248, 250, 252, 0.9)); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-radius: 16px; padding: 14px; margin: 10px 0; box-shadow: 0 8px 32px rgba(0,0,0,0.08), inset 0 1px 0 rgba(255,255,255,0.9); border: 1px solid rgba(255,255,255,0.6); position: relative; overflow: hidden;">\n`;
        content += `  <div style="display: flex; align-items: flex-start; justify-content: space-between; margin-bottom: 10px;">\n`;
        content += `    <div style="display: flex; align-items: center; flex: 1;">\n`;
        content += `      <span style="font-size: 32px; margin-right: 10px;">${emoji}</span>\n`;
        content += `      <div style="flex: 1;">\n`;
        content += `        <h3 style="color: #0f172a; margin: 0; font-size: 16px; font-weight: 600;">${item.food}</h3>\n`;
        content += `        <div style="color: #64748b; font-size: 12px; margin-top: 2px;">üìè ${item.quantity}</div>\n`;
        if (timeStr) {
          content += `        <div style="color: #64748b; font-size: 10px; margin-top: 1px; opacity: 0.8;">üïê ${timeStr}</div>\n`;
        }
        content += `      </div>\n`;
        content += `    </div>\n`;
        content += `    <button class="nutrition-edit-btn" data-food="${item.food.replace(/"/g, '&quot;')}" data-quantity="${item.quantity.replace(/"/g, '&quot;')}" data-calories="${item.calories}" data-protein="${item.protein}" data-carbs="${item.carbs}" data-fat="${item.fat}" data-edit-context="${editContext}" style="background: linear-gradient(135deg, rgba(255,255,255,0.7), rgba(248,250,252,0.5)); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border: 1px solid rgba(255,255,255,0.6); border-radius: 8px; padding: 6px 10px; color: #475569; font-size: 10px; cursor: pointer; margin-left: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.08), inset 0 1px 0 rgba(255,255,255,0.8); flex-shrink: 0;">‚úèÔ∏è Edit</button>\n`;
        content += `  </div>\n`;
        content += `  <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px;">\n`;
        content += `    <div style="text-align: center; padding: 8px; background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(254, 226, 226, 0.9)); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border-radius: 12px; border: 1px solid rgba(252, 165, 165, 0.3); box-shadow: 0 4px 16px rgba(239, 68, 68, 0.06), inset 0 1px 0 rgba(255,255,255,0.8);">\n`;
        content += `      <div style="font-size: 16px; margin-bottom: 2px;">üî•</div>\n`;
        content += `      <div style="color: #dc2626; font-weight: bold; font-size: 14px;">${item.calories}</div>\n`;
        content += `      <div style="color: #ef4444; font-size: 9px; text-transform: uppercase; font-weight: 600;">KCAL</div>\n`;
        content += `    </div>\n`;
        content += `    <div style="text-align: center; padding: 8px; background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(220, 252, 231, 0.9)); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border-radius: 12px; border: 1px solid rgba(134, 239, 172, 0.3); box-shadow: 0 4px 16px rgba(34, 197, 94, 0.06), inset 0 1px 0 rgba(255,255,255,0.8);">\n`;
        content += `      <div style="font-size: 16px; margin-bottom: 2px;">üí™</div>\n`;
        content += `      <div style="color: #16a34a; font-weight: bold; font-size: 14px;">${item.protein}g</div>\n`;
        content += `      <div style="color: #22c55e; font-size: 9px; text-transform: uppercase; font-weight: 600;">PROTEIN</div>\n`;
        content += `    </div>\n`;
        content += `    <div style="text-align: center; padding: 8px; background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(254, 243, 199, 0.9)); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border-radius: 12px; border: 1px solid rgba(252, 211, 77, 0.3); box-shadow: 0 4px 16px rgba(251, 191, 36, 0.06), inset 0 1px 0 rgba(255,255,255,0.8);">\n`;
        content += `      <div style="font-size: 16px; margin-bottom: 2px;">üåæ</div>\n`;
        content += `      <div style="color: #d97706; font-weight: bold; font-size: 14px;">${item.carbs}g</div>\n`;
        content += `      <div style="color: #f59e0b; font-size: 9px; text-transform: uppercase; font-weight: 600;">CARBS</div>\n`;
        content += `    </div>\n`;
        content += `    <div style="text-align: center; padding: 8px; background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(237, 233, 254, 0.9)); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border-radius: 12px; border: 1px solid rgba(196, 181, 253, 0.3); box-shadow: 0 4px 16px rgba(168, 85, 247, 0.06), inset 0 1px 0 rgba(255,255,255,0.8);">\n`;
        content += `      <div style="font-size: 16px; margin-bottom: 2px;">ü•ë</div>\n`;
        content += `      <div style="color: #7c3aed; font-weight: bold; font-size: 14px;">${item.fat}g</div>\n`;
        content += `      <div style="color: #8b5cf6; font-size: 9px; text-transform: uppercase; font-weight: 600;">FAT</div>\n`;
        content += `    </div>\n`;
        content += `  </div>\n`;
        content += `</div>\n\n`;
      }
    }
    
    return content;
  }

  private getEffectiveTheme(): 'light' | 'dark' {
    if (this.settings.displayTheme === 'auto') {
      // Auto-detect Obsidian's theme
      return document.body.classList.contains('theme-dark') ? 'dark' : 'light';
    }
    return this.settings.displayTheme as 'light' | 'dark';
  }

  private generateSimpleLayout(foodItems: FoodItem[], context?: 'meal' | 'foodlog'): string {
    let content = '';
    const isDark = this.getEffectiveTheme() === 'dark';
    const editContext = context || 'foodlog';
    
    for (const item of foodItems) {
      const emoji = item.emoji || 'üçΩÔ∏è';
      const entryId = `entry-${item.food.replace(/[^a-zA-Z0-9]/g, '-')}-${item.quantity.replace(/[^a-zA-Z0-9]/g, '-')}-${item.calories}`;
      
      // Time formatting
      let timeDisplay = '';
      if (item.timestamp) {
        const time = new Date(item.timestamp).toLocaleTimeString('en-US', { 
          hour: '2-digit', 
          minute: '2-digit' 
        });
        timeDisplay = ` üïê ${time}`;
      }
      
      // Clean theme-based styling
      const styles = isDark ? {
        background: 'linear-gradient(135deg, rgba(51, 65, 85, 0.6), rgba(30, 41, 59, 0.4))',
        borderColor: 'rgba(139, 92, 246, 0.6)',
        textColor: '#f8fafc',
        subtleColor: '#cbd5e1',
        quantityBg: 'rgba(255, 255, 255, 0.1)',
        shadow: '0 4px 16px rgba(0, 0, 0, 0.3)',
        editBtnBg: 'rgba(255, 255, 255, 0.08)',
        editBtnBorder: 'rgba(255, 255, 255, 0.15)'
      } : {
        background: 'linear-gradient(135deg, rgba(255, 255, 255, 0.8), rgba(248, 250, 252, 0.6))',
        borderColor: 'rgba(139, 92, 246, 0.5)',
        textColor: '#0f172a',
        subtleColor: '#475569',
        quantityBg: 'rgba(0, 0, 0, 0.05)',
        shadow: '0 4px 16px rgba(0, 0, 0, 0.08)',
        editBtnBg: 'rgba(0, 0, 0, 0.04)',
        editBtnBorder: 'rgba(0, 0, 0, 0.08)'
      };
      
      // Main container
      content += `<div id="${entryId}" class="nutrition-food-entry-simple ${entryId}" data-food="${item.food.replace(/"/g, '&quot;')}" data-quantity="${item.quantity.replace(/"/g, '&quot;')}" data-calories="${item.calories}" data-protein="${item.protein}" data-carbs="${item.carbs}" data-fat="${item.fat}" style="margin: 12px 0; padding: 16px 20px; background: ${styles.background}; border-left: 4px solid ${styles.borderColor}; border-radius: 0 12px 12px 0; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); box-shadow: ${styles.shadow}; overflow: hidden;">\n\n`;
      
      // Header with food name and edit button
      content += `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">\n`;
      content += `<h3 style="margin: 0; color: ${styles.textColor}; font-size: 18px; font-weight: 600;">${emoji} ${item.food}</h3>\n`;
      content += `<button class="nutrition-edit-btn" data-food="${item.food.replace(/"/g, '&quot;')}" data-quantity="${item.quantity.replace(/"/g, '&quot;')}" data-calories="${item.calories}" data-protein="${item.protein}" data-carbs="${item.carbs}" data-fat="${item.fat}" data-edit-context="${editContext}" style="background: ${styles.editBtnBg}; border: 1px solid ${styles.editBtnBorder}; color: ${styles.subtleColor}; cursor: pointer; font-size: 12px; padding: 4px 8px; border-radius: 6px; transition: all 0.2s ease; opacity: 0.8;" onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='0.8'">‚úèÔ∏è</button>\n`;
      content += `</div>\n\n`;
      
      // Quantity and time
      content += `<div style="color: ${styles.textColor}; font-weight: 500; margin-bottom: 10px;">\n`;
      content += `<span style="background: ${styles.quantityBg}; padding: 2px 8px; border-radius: 6px; font-size: 14px;">${item.quantity}</span>${timeDisplay}\n`;
      content += `</div>\n\n`;
      
      // Nutrition info
      content += `<div style="color: ${styles.subtleColor}; font-size: 14px; line-height: 1.5;">\n`;
      content += `üî• <span style="color: ${isDark ? '#f87171' : '#dc2626'}; font-weight: 600;">${item.calories} kcal</span> „Éª `;
      content += `üí™ <span style="color: ${isDark ? '#4ade80' : '#16a34a'}; font-weight: 600;">${item.protein}g protein</span> „Éª `;
      content += `üåæ <span style="color: ${isDark ? '#fbbf24' : '#d97706'}; font-weight: 600;">${item.carbs}g carbs</span> „Éª `;
      content += `ü•ë <span style="color: ${isDark ? '#a78bfa' : '#7c3aed'}; font-weight: 600;">${item.fat}g fat</span>\n`;
      content += `</div>\n\n`;
      
      content += `</div>\n\n`;
    }
    
    return content;
  }

  private async generateDailySummary(totals: NutritionData): Promise<string> {
    const goals = this.settings.nutritionGoals;
    const isDark = this.getEffectiveTheme() === 'dark';
    
    let summary = '## üìä Daily Summary\n\n';
    
    // Create glassy card wrapper similar to food cards but lighter
    const cardStyles = isDark ? {
      background: 'linear-gradient(135deg, rgba(51, 65, 85, 0.6), rgba(30, 41, 59, 0.5))',
      border: '1px solid rgba(148, 163, 184, 0.25)',
      shadow: '0 8px 32px rgba(0,0,0,0.2), inset 0 1px 0 rgba(255,255,255,0.08)',
      textColor: '#f8fafc',
      subtleColor: '#cbd5e1',
      footerColor: '#94a3b8'
    } : {
      background: 'linear-gradient(135deg, rgb(240 240 240 / 80%), rgba(248, 250, 252, 0.7))',
      border: '1px solid rgba(255, 255, 255, 0.7)',
      shadow: '0 8px 32px rgba(0,0,0,0.06), inset 0 1px 0 rgba(255,255,255,0.9)',
      textColor: '#0f172a',
      subtleColor: '#475569',
      footerColor: '#64748b'
    };
    
    // Create the entire card as a single-line HTML structure (like food item cards)
    const nutrients = [
      { name: 'Calories', emoji: 'üî•', current: totals.calories, goal: goals.calories, unit: 'kcal' },
      { name: 'Protein', emoji: 'üí™', current: totals.protein, goal: goals.protein, unit: 'g' },
      { name: 'Carbs', emoji: 'üåæ', current: totals.carbs, goal: goals.carbs, unit: 'g' },
      { name: 'Fat', emoji: 'ü•ë', current: totals.fat, goal: goals.fat, unit: 'g' }
    ];
    
    // Overall status
    const overallProgress = Math.round((
      this.calculatePercentage(totals.calories, goals.calories) +
      this.calculatePercentage(totals.protein, goals.protein) +
      this.calculatePercentage(totals.carbs, goals.carbs) +
      this.calculatePercentage(totals.fat, goals.fat)
    ) / 4);
    
    // Generate nutrition rows
    let nutritionRows = '';
    if (this.settings.progressBarStyle === 'modern-bars') {
      // For modern bars, get the progress bars but strip newlines and fix bold formatting
      nutritionRows = this.generateModernProgressBars(totals, goals).replace(/\n+/g, '').replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    } else {
      for (const nutrient of nutrients) {
        const percentage = this.calculatePercentage(nutrient.current, nutrient.goal);
        const progressBar = this.settings.progressBarStyle === 'percentage-only' ? '' : this.getProgressBar(nutrient.current, nutrient.goal);
        
        nutritionRows += `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; padding: 8px 0;"><span style="color: ${cardStyles.textColor}; font-weight: 500; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">${nutrient.emoji} ${nutrient.name}:</span><span style="color: ${cardStyles.subtleColor}; font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace; font-size: 13px; font-weight: 400;">${Math.round(nutrient.current)} / ${nutrient.goal} ${nutrient.unit}</span><span style="color: ${cardStyles.textColor}; font-weight: 400; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">${progressBar} ${percentage}%</span></div>`;
      }
    }
    
    // Build the entire card as a single line (like food item cards)
    // Create ultra-subtle glassy overall progress section
    const progressBg = isDark 
      ? 'rgba(255, 255, 255, 0.08)'
      : 'linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(248, 248, 248, 0.15))';
    
    const progressBorder = isDark 
      ? 'rgba(255, 255, 255, 0.15)'
      : 'rgba(255, 255, 255, 0.25)';
    
    // Enhanced divider with dark grey/resin color
    const dividerStyle = isDark 
      ? 'background: linear-gradient(90deg, transparent, rgba(60, 60, 60, 0.8), transparent); height: 1px; border: none;'
      : 'background: linear-gradient(90deg, transparent, rgba(80, 80, 80, 0.4), transparent); height: 1px; border: none;';
    
    // Enhanced overall progress border with gradient
    const enhancedProgressBorder = isDark 
      ? 'background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(148, 163, 184, 0.15)); padding: 1px; border-radius: 13px;'
      : 'background: linear-gradient(135deg, rgba(0, 0, 0, 0.15), rgba(100, 100, 100, 0.1)); padding: 1px; border-radius: 13px;';
    
    summary += `<div style="background: ${cardStyles.background}; backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); border-radius: 16px; padding: 20px; margin: 12px 0; box-shadow: ${cardStyles.shadow}; border: ${cardStyles.border};"><h3 style="color: ${cardStyles.textColor}; margin-top: 0; margin-bottom: 16px; font-size: 18px; font-weight: 500; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; letter-spacing: -0.5px;">üéØ Totals vs Goals</h3><div style="${dividerStyle} margin-bottom: 16px;"></div>${nutritionRows}<div style="${enhancedProgressBorder} text-align: center; margin: 32px 0 0;"><div style="background: ${progressBg}; border-radius: 12px; padding: 12px;"><h3 style="color: ${cardStyles.textColor}; margin: 0; font-size: 20px; font-weight: 500; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; letter-spacing: -0.8px;">${this.getOverallStatusEmoji(overallProgress)} Overall Progress: ${overallProgress}%</h3></div></div></div>\n\n`;
    
    return summary;
  }

  private generateModernProgressBars(totals: NutritionData, goals: any): string {
    let content = '';
    const isDark = this.getEffectiveTheme() === 'dark';
    
    const nutrients = [
      { name: 'Calories', emoji: 'üî•', current: totals.calories, goal: goals.calories, unit: 'kcal' },
      { name: 'Protein', emoji: 'üí™', current: totals.protein, goal: goals.protein, unit: 'g' },
      { name: 'Carbs', emoji: 'üåæ', current: totals.carbs, goal: goals.carbs, unit: 'g' },
      { name: 'Fat', emoji: 'ü•ë', current: totals.fat, goal: goals.fat, unit: 'g' }
    ];
    
    for (const nutrient of nutrients) {
      const percentage = this.calculatePercentage(nutrient.current, nutrient.goal);
      const { gradient, textColor, borderColor } = this.getProgressGradient(percentage, isDark);
      
      // Ultra-subtle glassy track background with enhanced borders
      const trackBg = isDark 
        ? 'linear-gradient(135deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.01))'
        : 'linear-gradient(135deg, rgba(0, 0, 0, 0.02), rgba(0, 0, 0, 0.01))';
      
      const trackBorder = isDark 
        ? 'rgba(255, 255, 255, 0.12)' 
        : 'rgba(0, 0, 0, 0.12)';
      
      const trackShadow = isDark 
        ? 'inset 0 1px 2px rgba(0, 0, 0, 0.1), 0 1px 0 rgba(255, 255, 255, 0.03)'
        : 'inset 0 1px 2px rgba(0, 0, 0, 0.06), 0 1px 0 rgba(255, 255, 255, 0.8)';
      
      content += `<span style="color: ${isDark ? '#e0e0e0' : '#333'}; font-weight: 500; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; font-size: 15px; letter-spacing: -0.3px;">${nutrient.emoji} ${nutrient.name}:</span> <span style="color: ${isDark ? '#a0a0a0' : '#666'}; font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace; font-size: 13px; font-weight: 400;">${Math.round(nutrient.current)} / ${nutrient.goal} ${nutrient.unit}</span> `;
      content += `<span style="color: ${textColor}; font-weight: 500; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; font-size: 14px;">(${percentage}%)</span>\n`;
      
      // Ultra-minimalistic glassy progress bar with enhanced visibility
      content += `<div style="width: 100%; background: ${trackBg}; border: 1px solid ${trackBorder}; border-radius: 10px; height: 16px; margin: 6px 0 12px 0; padding: 2px; backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px); box-shadow: ${trackShadow};">\n`;
      content += `  <div style="width: ${Math.min(percentage, 100)}%; background: ${gradient}; height: 100%; border-radius: 8px; border: 1px solid ${borderColor}; transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1); position: relative; overflow: hidden; backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);">\n`;
      
      // Enhanced glass shine effect with theme adaptation
      if (percentage > 0) {
        const shineOpacity = isDark ? 0.06 : 0.12;
        const shineFade = shineOpacity * 0.3;
        content += `    <div style="position: absolute; top: 0; left: 0; right: 0; height: 50%; background: linear-gradient(180deg, rgba(255,255,255,${shineOpacity}) 0%, rgba(255,255,255,${shineFade}) 70%, transparent 100%); border-radius: 8px 8px 0 0;"></div>\n`;
        
        // Subtle inner glow
        const glowOpacity = isDark ? 0.03 : 0.04;
        content += `    <div style="position: absolute; inset: 0; border-radius: 8px; box-shadow: inset 0 0 8px rgba(255,255,255,${glowOpacity});"></div>\n`;
      }
      
      content += `  </div>\n`;
      content += `</div>\n\n`;
    }
    
    return content;
  }

  private getPercentageColor(percentage: number): string {
    const isDark = this.getEffectiveTheme() === 'dark';
    
    if (percentage <= 30) {
      return isDark ? '#ef4444' : '#dc2626'; // Red
    } else if (percentage <= 70) {
      return isDark ? '#f59e0b' : '#d97706'; // Orange
    } else {
      return isDark ? '#10b981' : '#059669'; // Green
    }
  }

  private getProgressGradient(percentage: number, isDark: boolean): { gradient: string, textColor: string, borderColor: string } {
    // Smooth, muted color transitions: Red (0%) ‚Üí Orange (50%) ‚Üí Green (100%)
    // Cap at 100% to prevent color changes beyond completion
    const cappedPercentage = Math.min(percentage, 100);
    let r, g, b;
    
    if (isDark) {
      // Dark theme: Natural, muted colors with good visibility
      if (cappedPercentage <= 50) {
        // Red to Yellow transition (0% to 50%) - natural warm tones
        const factor = cappedPercentage / 50;
        r = Math.round(200 + (220 - 200) * factor); // 200 (natural red) to 220 (natural yellow)
        g = Math.round(90 + (180 - 90) * factor);   // 90 (natural red) to 180 (natural yellow)
        b = Math.round(90 + (85 - 90) * factor);    // 90 (natural red) to 85 (natural yellow)
      } else {
        // Yellow to Green transition (50% to 100%) - natural warm to cool
        const factor = (cappedPercentage - 50) / 50;
        r = Math.round(220 - (220 - 110) * factor); // 220 (natural yellow) to 110 (natural green)
        g = Math.round(180 - (180 - 170) * factor); // 180 (natural yellow) to 170 (natural green)
        b = Math.round(85 + (110 - 85) * factor);   // 85 (natural yellow) to 110 (natural green)
      }
    } else {
      // Light theme: Natural, muted colors - traffic light progression
      if (cappedPercentage <= 50) {
        // Red to Yellow transition (0% to 50%) - natural coral to warm yellow
        const factor = cappedPercentage / 50;
        r = Math.round(190 + (210 - 190) * factor); // 190 (natural coral) to 210 (natural yellow)
        g = Math.round(110 + (175 - 110) * factor); // 110 (natural coral) to 175 (natural yellow)
        b = Math.round(110 + (90 - 110) * factor);  // 110 (natural coral) to 90 (natural yellow)
      } else {
        // Yellow to Green transition (50% to 100%) - natural yellow to sage
        const factor = (cappedPercentage - 50) / 50;
        r = Math.round(210 - (210 - 130) * factor); // 210 (natural yellow) to 130 (natural sage)
        g = Math.round(175 - (175 - 150) * factor); // 175 (natural yellow) to 150 (natural sage)
        b = Math.round(90 + (120 - 90) * factor);   // 90 (natural yellow) to 120 (natural sage)
      }
    }
    
    // Create glassy gradients with enhanced visibility for dark theme
    const baseOpacity = isDark ? 0.45 : 0.3;
    const primaryColor = `rgba(${r}, ${g}, ${b}, ${baseOpacity})`;
    const secondaryColor = `rgba(${r}, ${g}, ${b}, ${baseOpacity * 0.6})`;
    
    // Multi-stop gradient for more sophisticated glass effect
    const gradient = `linear-gradient(135deg, ${primaryColor} 0%, rgba(${r}, ${g}, ${b}, ${baseOpacity * 0.8}) 50%, ${secondaryColor} 100%)`;
    
    // Enhanced border visibility for dark theme
    const borderOpacity = isDark ? 0.6 : 0.45;
    const borderColor = `rgba(${r}, ${g}, ${b}, ${borderOpacity})`;
    
    // Text color - enhanced visibility for dark theme
    const textOpacity = isDark ? 0.95 : 0.75;
    const textColor = `rgba(${Math.round(r * 0.9)}, ${Math.round(g * 0.9)}, ${Math.round(b * 0.9)}, ${textOpacity})`;
    
    return { gradient, textColor, borderColor };
  }

  private async recalculateTotals(content: string): Promise<string> {
    // Extract all nutrition values from the content
    const foodItems = this.extractFoodItemsFromContent(content);
    const totals = this.calculateTotals(foodItems);
    
    // Generate the new summary
    const newSummary = await this.generateDailySummary(totals);
    
    // Check if there's already a summary to replace (including any existing footer)
    const summaryRegex = /## üìä Daily Summary[\s\S]*?(?=\n---\n\n\*‚ú® Generated by|$)/;
    const footerRegex = /\n---\n\n\*‚ú® Generated by.*?Plugin\*\n*$/;
    
    if (summaryRegex.test(content)) {
      // Replace existing summary and footer
      let updatedContent = content.replace(summaryRegex, newSummary.trim());
      // Remove any existing footer
      updatedContent = updatedContent.replace(footerRegex, '');
      // Add new footer
      return updatedContent + '\n---\n\n*‚ú® Generated by AI Nutrition Tracker Plugin*\n';
    } else {
      // Add new summary and footer at the end
      let updatedContent = content;
      // Remove any existing footer first
      updatedContent = updatedContent.replace(footerRegex, '');
      return updatedContent + '\n' + newSummary.trim() + '\n---\n\n*‚ú® Generated by AI Nutrition Tracker Plugin*\n';
    }
  }

  private extractFoodItemsFromContent(content: string): FoodItem[] {
    const items: FoodItem[] = [];
    
    // Try simple layout first (most common - data-food, data-quantity, etc.)
    const simpleRegex = /class="nutrition-food-entry-simple[^"]*"[^>]*data-food="([^"]*)"[^>]*data-quantity="([^"]*)"[^>]*data-calories="([^"]*)"[^>]*data-protein="([^"]*)"[^>]*data-carbs="([^"]*)"[^>]*data-fat="([^"]*)"/g;
    
    // Try card layout (data-ntr-food, data-ntr-quantity, etc.)
    const cardAttributeRegex = /<div[^>]*data-ntr-food="([^"]*)"[^>]*data-ntr-quantity="([^"]*)"[^>]*data-ntr-calories="([\d.]+)"[^>]*data-ntr-protein="([\d.]+)"[^>]*data-ntr-carbs="([\d.]+)"[^>]*data-ntr-fat="([\d.]+)"[^>]*>/g;
    
    // Extract from old HTML card layouts (fallback)
    const htmlCardRegex = /<div style="background: linear-gradient\(135deg,[^"]+\)"[\s\S]*?<h3[^>]*>([^<]+)<\/h3>[\s\S]*?üìè ([^<]+)[\s\S]*?<div style="color: [^"]+; font-weight: bold; font-size: 14px;">([\d.]+)<\/div>[\s\S]*?<div style="color: [^"]+; font-weight: bold; font-size: 14px;">([\d.]+)g<\/div>[\s\S]*?<div style="color: [^"]+; font-weight: bold; font-size: 14px;">([\d.]+)g<\/div>[\s\S]*?<div style="color: [^"]+; font-weight: bold; font-size: 14px;">([\d.]+)g<\/div>/g;
    
    // Try simple layout first (most reliable for new entries)
    let match;
    while ((match = simpleRegex.exec(content)) !== null) {
      items.push({
        food: match[1].replace(/&quot;/g, '"'),
        quantity: match[2].replace(/&quot;/g, '"'),
        calories: parseFloat(match[3]),
        protein: parseFloat(match[4]),
        carbs: parseFloat(match[5]),
        fat: parseFloat(match[6])
      });
    }
    
    // If no simple layout entries found, try card layout
    if (items.length === 0) {
      while ((match = cardAttributeRegex.exec(content)) !== null) {
        // Extract all nutrition data from card data attributes
        const food = match[1].replace(/&quot;/g, '"');
        const quantity = match[2].replace(/&quot;/g, '"');
        const calories = parseFloat(match[3]);
        const protein = parseFloat(match[4]);
        const carbs = parseFloat(match[5]);
        const fat = parseFloat(match[6]);
        
        items.push({
          food,
          quantity,
          calories,
          protein,
          carbs,
          fat
        });
      }
    }
    
    // If still no items found, try old HTML card pattern
    if (items.length === 0) {
      while ((match = htmlCardRegex.exec(content)) !== null) {
        items.push({
          food: match[1].trim(),
          quantity: match[2].trim(),
          calories: parseFloat(match[3]),
          protein: parseFloat(match[4]),
          carbs: parseFloat(match[5]),
          fat: parseFloat(match[6])
        });
      }
    }
    
    return items;
  }

  private calculateTotals(foodItems: FoodItem[]): NutritionData {
    return foodItems.reduce((totals, item) => ({
      calories: totals.calories + (item.calories || 0),
      protein: totals.protein + (item.protein || 0),
      carbs: totals.carbs + (item.carbs || 0),
      fat: totals.fat + (item.fat || 0)
    }), { calories: 0, protein: 0, carbs: 0, fat: 0 });
  }

  private calculatePercentage(current: number, goal: number): number {
    if (goal === 0) return 0;
    return Math.round((current / goal) * 100);
  }

  private getTodayString(): string {
    const today = new Date();
    return today.toISOString().split('T')[0]; // YYYY-MM-DD
  }

  private async ensureDirectoryExists(path: string): Promise<void> {
    console.log('Ensuring directory exists for path:', path);
    const dirs = path.split('/');
    let currentPath = '';
    
    for (const dir of dirs) {
      currentPath = currentPath ? `${currentPath}/${dir}` : dir;
      console.log('Checking/creating directory:', currentPath);
      
      const exists = this.vault.getAbstractFileByPath(currentPath);
      if (!exists) {
        console.log('Directory does not exist, creating:', currentPath);
        try {
          await this.vault.createFolder(currentPath);
          console.log('Successfully created directory:', currentPath);
        } catch (error) {
          console.error('Failed to create directory:', currentPath, error);
          throw new Error(`Failed to create directory ${currentPath}: ${error.message}`);
        }
      } else {
        console.log('Directory already exists:', currentPath);
      }
    }
    console.log('Directory creation completed for path:', path);
  }

  async saveImage(imageFile: File): Promise<string> {
    try {
      await this.ensureDirectoryExists(this.settings.imageStoragePath);
      
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const extension = imageFile.name.split('.').pop() || 'jpg';
      const filename = `food-image-${timestamp}.${extension}`;
      const imagePath = `${this.settings.imageStoragePath}/${filename}`;
      
      // Convert File to ArrayBuffer
      const arrayBuffer = await imageFile.arrayBuffer();
      await this.vault.createBinary(imagePath, arrayBuffer);
      
      return imagePath;
    } catch (error) {
      console.error('Error saving image:', error);
      throw new Error(`Failed to save image: ${error.message}`);
    }
  }



  private getProgressBar(current: number, goal: number): string {
    const percentage = this.calculatePercentage(current, goal);
    const filledBlocks = Math.min(10, Math.round(percentage / 10));
    const emptyBlocks = 10 - filledBlocks;
    const isDark = this.getEffectiveTheme() === 'dark';
    
    let bar = '';
    
    // Enhanced emoji selection with smooth transitions
    for (let i = 0; i < 10; i++) {
      const blockPercentage = ((i + 1) * 10);
      
      if (blockPercentage <= percentage) {
        // This block is filled - choose color based on overall percentage
        if (percentage >= 90) {
          bar += 'üü¢'; // Bright green for excellent progress
        } else if (percentage >= 70) {
          bar += i < 7 ? 'üü¢' : 'üü°'; // Mix of green and yellow
        } else if (percentage >= 50) {
          bar += i < 5 ? 'üü†' : 'üü°'; // Mix of orange and yellow  
        } else if (percentage >= 30) {
          bar += i < 3 ? 'üî¥' : 'üü†'; // Mix of red and orange
        } else {
          bar += 'üî¥'; // Red for low progress
        }
      } else {
        // Empty block - use theme-appropriate empty indicator
        bar += isDark ? '‚ö´' : '‚ö™';
      }
    }
    
    return bar;
  }

  private getOverallStatusEmoji(percentage: number): string {
    if (percentage >= 95) return 'üèÜ'; // Trophy for exceptional achievement
    if (percentage >= 90) return 'üéâ'; // Party for great progress
    if (percentage >= 80) return 'üî•'; // Fire for strong progress
    if (percentage >= 70) return 'üí™'; // Muscle for good progress
    if (percentage >= 60) return 'üìà'; // Chart for steady progress
    if (percentage >= 50) return '‚ö°'; // Lightning for halfway there
    if (percentage >= 30) return 'üå±'; // Seedling for growing progress
    if (percentage >= 10) return 'üèÉ‚Äç‚ôÇÔ∏è'; // Runner for getting started
    return 'üåü'; // Star for motivation to begin
  }

  // Meal storage methods
  private getMealsFilePath(): string {
    return `${this.settings.mealStoragePath}/meals.json`;
  }

  async saveMeal(name: string, foodItems: FoodItem[], description?: string, images?: string[]): Promise<Meal> {
    const meal: Meal = {
      id: this.generateMealId(),
      name: name.trim(),
      items: foodItems.map(item => {
        const { mealId, ...itemWithoutMealId } = item;
        return itemWithoutMealId;
      }),
      description: description?.trim(),
      images: images || [],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };

    try {
      // Save to JSON storage
      const meals = await this.getMeals();
      meals.push(meal);
      await this.saveMealsToFile(meals);
      
      // Create individual markdown note for the meal
      await this.createMealNote(meal);
      
      new Notice(`‚úÖ Meal "${name}" saved successfully`);
      return meal;
    } catch (error) {
      console.error('Error saving meal:', error);
      new Notice(`‚ùå Failed to save meal: ${error.message}`);
      throw new Error(`Failed to save meal: ${error.message}`);
    }
  }

  async getMeals(): Promise<Meal[]> {
    try {
      const mealsPath = this.getMealsFilePath();
      const mealsFile = this.vault.getAbstractFileByPath(mealsPath);
      
      if (!mealsFile || !(mealsFile instanceof TFile)) {
        // File doesn't exist, return empty array
        return [];
      }

      const content = await this.vault.read(mealsFile);
      const meals = JSON.parse(content);
      
      // Validate meals format
      if (!Array.isArray(meals)) {
        console.warn('Invalid meals file format, returning empty array');
        return [];
      }

      return meals;
    } catch (error) {
      console.error('Error loading meals:', error);
      return [];
    }
  }

  async updateMeal(mealId: string, updates: Partial<Meal>): Promise<void> {
    try {
      const meals = await this.getMeals();
      const mealIndex = meals.findIndex(m => m.id === mealId);
      
      if (mealIndex === -1) {
        throw new Error(`Meal with ID ${mealId} not found`);
      }

      const oldMeal = meals[mealIndex];
      const updatedMeal = {
        ...oldMeal,
        ...updates,
        updatedAt: new Date().toISOString()
      };
      
      meals[mealIndex] = updatedMeal;

      await this.saveMealsToFile(meals);
      
      // Update the markdown note
      await this.updateMealNote(oldMeal, updatedMeal);
      
      new Notice(`‚úÖ Meal "${updatedMeal.name}" updated successfully`);
    } catch (error) {
      console.error('Error updating meal:', error);
      throw new Error(`Failed to update meal: ${error.message}`);
    }
  }

  async deleteMeal(mealId: string): Promise<void> {
    try {
      const meals = await this.getMeals();
      const mealIndex = meals.findIndex(m => m.id === mealId);
      
      if (mealIndex === -1) {
        throw new Error(`Meal with ID ${mealId} not found`);
      }

      const mealToDelete = meals[mealIndex];
      meals.splice(mealIndex, 1);
      
      await this.saveMealsToFile(meals);
      
      // Delete the markdown note
      await this.deleteMealNote(mealToDelete);
      
      new Notice(`‚úÖ Meal "${mealToDelete.name}" deleted successfully`);
    } catch (error) {
      console.error('Error deleting meal:', error);
      throw new Error(`Failed to delete meal: ${error.message}`);
    }
  }

  async getMealById(mealId: string): Promise<Meal | null> {
    try {
      const meals = await this.getMeals();
      return meals.find(m => m.id === mealId) || null;
    } catch (error) {
      console.error('Error getting meal by ID:', error);
      return null;
    }
  }

  private async saveMealsToFile(meals: Meal[]): Promise<void> {
    try {
      const mealsPath = this.getMealsFilePath();
      console.log('Saving meals to file path:', mealsPath);
      
      // Ensure directory exists
      console.log('Ensuring directory exists for:', this.settings.mealStoragePath);
      await this.ensureDirectoryExists(this.settings.mealStoragePath);
      
      const content = JSON.stringify(meals, null, 2);
      console.log('Meals content to save:', content);
      
      const existingFile = this.vault.getAbstractFileByPath(mealsPath);
      console.log('Existing file found:', !!existingFile);
      
      if (existingFile instanceof TFile) {
        console.log('Modifying existing file...');
        await this.vault.modify(existingFile, content);
        console.log('Successfully modified existing file');
      } else {
        console.log('Creating new file...');
        await this.vault.create(mealsPath, content);
        console.log('Successfully created new file');
      }
      
      // Verify file was created/updated
      const verifyFile = this.vault.getAbstractFileByPath(mealsPath);
      console.log('Verification: File exists after save:', !!verifyFile);
      
    } catch (error) {
      console.error('Error saving meals to file:', error);
      console.error('Meals path:', this.getMealsFilePath());
      console.error('Storage path:', this.settings.mealStoragePath);
      console.error('Full error:', error);
      throw error;
    }
  }

  private generateMealId(): string {
    return 'meal_' + Date.now().toString(36) + '_' + Math.random().toString(36).substr(2, 9);
  }

  private async createMealNote(meal: Meal): Promise<void> {
    try {
      // Sanitize meal name for filename
      const sanitizedName = meal.name.replace(/[^a-zA-Z0-9\s-]/g, '').replace(/\s+/g, '-').toLowerCase();
      const timestamp = new Date(meal.createdAt).toISOString().split('T')[0]; // YYYY-MM-DD
      const filename = `${timestamp}-${sanitizedName}.md`;
      const notePath = `${this.settings.mealStoragePath}/${filename}`;
      
      // Generate meal note content
      const content = await this.generateMealNoteContent(meal);
      
      // Check if file already exists
      const existingFile = this.vault.getAbstractFileByPath(notePath);
      if (existingFile) {
        // File exists, modify it
        await this.vault.modify(existingFile as TFile, content);
      } else {
        // Create new file
        await this.vault.create(notePath, content);
      }
      
      console.log(`Created meal note: ${notePath}`);
    } catch (error) {
      console.error('Error creating meal note:', error);
      // Don't throw here - we don't want to fail the whole meal save if note creation fails
      new Notice(`Warning: Failed to create meal note: ${error.message}`);
    }
  }

  private async updateMealNote(oldMeal: Meal, newMeal: Meal): Promise<void> {
    try {
      // Delete old note if name changed
      if (oldMeal.name !== newMeal.name) {
        await this.deleteMealNote(oldMeal);
      }
      
      // Create/update new note
      await this.createMealNote(newMeal);
      
      console.log(`Updated meal note for: ${newMeal.name}`);
    } catch (error) {
      console.error('Error updating meal note:', error);
      new Notice(`Warning: Failed to update meal note: ${error.message}`);
    }
  }

  private async deleteMealNote(meal: Meal): Promise<void> {
    try {
      const sanitizedName = meal.name.replace(/[^a-zA-Z0-9\s-]/g, '').replace(/\s+/g, '-').toLowerCase();
      const timestamp = new Date(meal.createdAt).toISOString().split('T')[0]; // YYYY-MM-DD
      const filename = `${timestamp}-${sanitizedName}.md`;
      const notePath = `${this.settings.mealStoragePath}/${filename}`;
      
      const existingFile = this.vault.getAbstractFileByPath(notePath);
      if (existingFile instanceof TFile) {
        await this.vault.delete(existingFile);
        console.log(`Deleted meal note: ${notePath}`);
      }
    } catch (error) {
      console.error('Error deleting meal note:', error);
      new Notice(`Warning: Failed to delete meal note: ${error.message}`);
    }
  }

  private async generateMealNoteContent(meal: Meal): Promise<string> {
    const createdDate = new Date(meal.createdAt).toLocaleDateString();
    const totalCalories = meal.items.reduce((sum, item) => sum + item.calories, 0);
    const totalProtein = meal.items.reduce((sum, item) => sum + item.protein, 0);
    const totalCarbs = meal.items.reduce((sum, item) => sum + item.carbs, 0);
    const totalFat = meal.items.reduce((sum, item) => sum + item.fat, 0);
    
    // Create totals object for progress summary
    const totals = {
      calories: totalCalories,
      protein: totalProtein,
      carbs: totalCarbs,
      fat: totalFat
    };
    
    let content = `# üçΩÔ∏è ${meal.name}\n\n`;
    content += `**Created:** ${createdDate}\n`;
    content += `**Items:** ${meal.items.length}\n`;
    content += `**Total Calories:** ${totalCalories} kcal\n\n`;
    
    // Add editing instructions
    content += `> **‚úèÔ∏è Editing Instructions:**\n`;
    content += `> - Edit this meal by modifying the food items below\n`;
    content += `> - Changes will update the meal template for **future use only**\n`;
    content += `> - **Past food logs will NOT be affected** - they remain as logged\n`;
    content += `> - Save this file to sync changes back to meal storage\n\n`;
    
    if (meal.description) {
      content += `## üìù Description\n${meal.description}\n\n`;
    }
    
    content += `## ü•ó Meal Items\n\n`;
    
    // Generate food items using the same card layout as food logs but with meal context
    content += this.generateCardLayout(meal.items, 'meal');
    
    // Add beautiful progress summary instead of simple table
    content += await this.generateMealProgressSummary(totals);
    
    // Add meal metadata
    content += `---\n\n`;
    content += `**Meal ID:** \`${meal.id}\`\n`;
    content += `**Created:** ${meal.createdAt}\n`;
    content += `**Last Updated:** ${meal.updatedAt}\n\n`;
    content += `*‚ú® Generated by AI Nutrition Tracker Plugin*\n`;
    
    return content;
  }

  private async generateMealProgressSummary(totals: NutritionData): Promise<string> {
    const goals = this.settings.nutritionGoals;
    const isDark = this.getEffectiveTheme() === 'dark';
    
    let summary = '## üéØ Meal vs Goals\n\n';
    
    // Create glassy card wrapper similar to food cards but lighter
    const cardStyles = isDark ? {
      background: 'linear-gradient(135deg, rgba(51, 65, 85, 0.6), rgba(30, 41, 59, 0.5))',
      border: '1px solid rgba(148, 163, 184, 0.25)',
      shadow: '0 8px 32px rgba(0,0,0,0.2), inset 0 1px 0 rgba(255,255,255,0.08)',
      textColor: '#f8fafc',
      subtleColor: '#cbd5e1',
      footerColor: '#94a3b8'
    } : {
      background: 'linear-gradient(135deg, rgb(240 240 240 / 80%), rgba(248, 250, 252, 0.7))',
      border: '1px solid rgba(255, 255, 255, 0.7)',
      shadow: '0 8px 32px rgba(0,0,0,0.06), inset 0 1px 0 rgba(255,255,255,0.9)',
      textColor: '#0f172a',
      subtleColor: '#475569',
      footerColor: '#64748b'
    };
    
    // Create the entire card as a single-line HTML structure (like food item cards)
    const nutrients = [
      { name: 'Calories', emoji: 'üî•', current: totals.calories, goal: goals.calories, unit: 'kcal' },
      { name: 'Protein', emoji: 'üí™', current: totals.protein, goal: goals.protein, unit: 'g' },
      { name: 'Carbs', emoji: 'üåæ', current: totals.carbs, goal: goals.carbs, unit: 'g' },
      { name: 'Fat', emoji: 'ü•ë', current: totals.fat, goal: goals.fat, unit: 'g' }
    ];
    
    // Overall status
    const overallProgress = Math.round((
      this.calculatePercentage(totals.calories, goals.calories) +
      this.calculatePercentage(totals.protein, goals.protein) +
      this.calculatePercentage(totals.carbs, goals.carbs) +
      this.calculatePercentage(totals.fat, goals.fat)
    ) / 4);
    
    // Generate nutrition rows
    let nutritionRows = '';
    if (this.settings.progressBarStyle === 'modern-bars') {
      // For modern bars, get the progress bars but strip newlines and fix bold formatting
      nutritionRows = this.generateModernProgressBars(totals, goals).replace(/\n+/g, '').replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
    } else {
      for (const nutrient of nutrients) {
        const percentage = this.calculatePercentage(nutrient.current, nutrient.goal);
        const progressBar = this.settings.progressBarStyle === 'percentage-only' ? '' : this.getProgressBar(nutrient.current, nutrient.goal);
        
        nutritionRows += `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; padding: 8px 0;"><span style="color: ${cardStyles.textColor}; font-weight: 500; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">${nutrient.emoji} ${nutrient.name}:</span><span style="color: ${cardStyles.subtleColor}; font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace; font-size: 13px; font-weight: 400;">${Math.round(nutrient.current)} / ${nutrient.goal} ${nutrient.unit}</span><span style="color: ${cardStyles.textColor}; font-weight: 400; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">${progressBar} ${percentage}%</span></div>`;
      }
    }
    
    // Build the entire card as a single line (like food item cards)
    // Create ultra-subtle glassy overall progress section
    const progressBg = isDark 
      ? 'rgba(255, 255, 255, 0.08)'
      : 'linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(248, 248, 248, 0.15))';
    
    const progressBorder = isDark 
      ? 'rgba(255, 255, 255, 0.15)'
      : 'rgba(255, 255, 255, 0.25)';
    
    // Enhanced divider with dark grey/resin color
    const dividerStyle = isDark 
      ? 'background: linear-gradient(90deg, transparent, rgba(60, 60, 60, 0.8), transparent); height: 1px; border: none;'
      : 'background: linear-gradient(90deg, transparent, rgba(80, 80, 80, 0.4), transparent); height: 1px; border: none;';
    
    // Enhanced overall progress border with gradient
    const enhancedProgressBorder = isDark 
      ? 'background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(148, 163, 184, 0.15)); padding: 1px; border-radius: 13px;'
      : 'background: linear-gradient(135deg, rgba(0, 0, 0, 0.15), rgba(100, 100, 100, 0.1)); padding: 1px; border-radius: 13px;';
    
    summary += `<div style="background: ${cardStyles.background}; backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); border-radius: 16px; padding: 20px; margin: 12px 0; box-shadow: ${cardStyles.shadow}; border: ${cardStyles.border};"><h3 style="color: ${cardStyles.textColor}; margin-top: 0; margin-bottom: 16px; font-size: 18px; font-weight: 500; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; letter-spacing: -0.5px;">üéØ Meal vs Goals</h3><div style="${dividerStyle} margin-bottom: 16px;"></div>${nutritionRows}<div style="${enhancedProgressBorder} text-align: center; margin: 32px 0 0;"><div style="background: ${progressBg}; border-radius: 12px; padding: 12px;"><h3 style="color: ${cardStyles.textColor}; margin: 0; font-size: 20px; font-weight: 500; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; letter-spacing: -0.8px;">${this.getOverallStatusEmoji(overallProgress)} Overall Progress: ${overallProgress}%</h3></div></div></div>\n\n`;
    
    return summary;
  }

  // Methods for syncing meal notes back to JSON
  isMealNote(file: TAbstractFile): boolean {
    if (!(file instanceof TFile)) return false;
    
    // Check if file is in meal storage path and has .md extension
    const normalizedPath = file.path.replace(/\\/g, '/');
    const normalizedMealPath = this.settings.mealStoragePath.replace(/\\/g, '/');
    const normalizedLogPath = this.settings.logStoragePath.replace(/\\/g, '/');
    
    // Must be in meal storage path
    const inMealPath = normalizedPath.startsWith(normalizedMealPath);
    
    // Must NOT be in log storage path (prevent cross-contamination)
    const inLogPath = normalizedPath.startsWith(normalizedLogPath);
    
    // Must have .md extension and not be meals.json
    const validExtension = file.extension === 'md' && file.name !== 'meals.json';
    
    // Must not be a food log (food logs typically have format "YYYY-MM-DD.md")
    const isFoodLog = /^\d{4}-\d{2}-\d{2}\.md$/.test(file.name);
    
    console.log(`üîç File detection for "${file.path}":`);
    console.log(`  - In meal path: ${inMealPath}`);
    console.log(`  - In log path: ${inLogPath}`);
    console.log(`  - Valid extension: ${validExtension}`);
    console.log(`  - Is food log pattern: ${isFoodLog}`);
    
    const isMealNote = inMealPath && !inLogPath && validExtension && !isFoodLog;
    console.log(`  - RESULT: Is meal note = ${isMealNote}`);
    
    return isMealNote;
  }

  async syncMealNoteToJSON(file: TFile): Promise<void> {
    try {
      console.log('üîÑ Syncing meal note to JSON (MEAL TEMPLATE ONLY):', file.path);
      console.log('üìã This will NOT affect any past food logs - only future uses of this meal');
      
      const content = await this.vault.read(file);
      
      // Double-check that this is actually a meal note by looking for meal ID
      if (!content.includes('**Meal ID:**')) {
        console.warn('‚ùå File does not contain meal ID - this is NOT a meal note, skipping sync:', file.path);
        console.warn('File content preview:', content.substring(0, 200) + '...');
        return;
      }
      
      const parsedMeal = this.parseMealFromMarkdown(content);
      
      if (!parsedMeal) {
        console.warn('Could not parse meal from markdown:', file.path);
        return;
      }
      
      // IMPORTANT: Only update the meal template in JSON storage
      // This will NOT affect any existing food logs that used this meal
      const meals = await this.getMeals();
      const mealIndex = meals.findIndex(m => m.id === parsedMeal.id);
      
      if (mealIndex >= 0) {
        const oldMeal = meals[mealIndex];
        
        // Update existing meal template
        const updatedMeal = {
          ...oldMeal,
          name: parsedMeal.name,
          items: parsedMeal.items,
          description: parsedMeal.description,
          updatedAt: new Date().toISOString()
        };
        
        meals[mealIndex] = updatedMeal;
        await this.saveMealsToFile(meals);
        
        console.log('‚úÖ Meal TEMPLATE updated in JSON:', updatedMeal.name);
        console.log('üìù Past food logs using this meal remain unchanged');
        console.log('üîÆ Future uses of this meal will use the updated version');
        
        new Notice(`‚úÖ Meal template "${updatedMeal.name}" updated for future use`);
      } else {
        console.warn('Meal not found in JSON storage:', parsedMeal.id);
        new Notice(`‚ö†Ô∏è Meal not found in storage - this might be an orphaned meal note`);
      }
    } catch (error) {
      console.error('Error syncing meal note to JSON:', error);
      new Notice(`‚ùå Failed to sync meal: ${error.message}`);
    }
  }

  private parseMealFromMarkdown(content: string): Partial<Meal> | null {
    try {
      // Extract meal ID from metadata
      const mealIdMatch = content.match(/\*\*Meal ID:\*\*\s*`([^`]+)`/);
      if (!mealIdMatch) {
        console.warn('No meal ID found in markdown');
        return null;
      }
      
      const mealId = mealIdMatch[1];
      
      // Extract meal name from title
      const titleMatch = content.match(/^#\s*üçΩÔ∏è\s*(.+)$/m);
      const mealName = titleMatch ? titleMatch[1].trim() : 'Unnamed Meal';
      
      // Extract description
      const descriptionMatch = content.match(/## üìù Description\n([\s\S]+?)\n\n/);
      const description = descriptionMatch ? descriptionMatch[1].trim() : undefined;
      
      // Extract food items from card layout
      const foodItems = this.extractFoodItemsFromContent(content);
      
      return {
        id: mealId,
        name: mealName,
        items: foodItems,
        description
      };
    } catch (error) {
      console.error('Error parsing meal from markdown:', error);
      return null;
    }
  }

  // Method to regenerate meal note after sync (to update totals)
  async regenerateMealNote(mealId: string): Promise<void> {
    try {
      const meal = await this.getMealById(mealId);
      if (meal) {
        await this.createMealNote(meal);
        console.log('‚úÖ Meal note regenerated:', meal.name);
      }
    } catch (error) {
      console.error('Error regenerating meal note:', error);
    }
  }

  // Method to update a specific item within a meal template
  async updateMealItem(originalItem: { food: string, quantity: string, calories: number, protein: number, carbs: number, fat: number }, newItem: FoodItem): Promise<void> {
    try {
      console.log('üîÑ Updating meal item:', originalItem.food, '‚Üí', newItem.food);
      
      const meals = await this.getMeals();
      let mealFound = false;
      
      // Find the meal that contains this item
      for (const meal of meals) {
        const itemIndex = meal.items.findIndex(item => 
          item.food === originalItem.food &&
          item.quantity === originalItem.quantity &&
          item.calories === originalItem.calories
        );
        
        if (itemIndex >= 0) {
          console.log('‚úÖ Found item in meal:', meal.name);
          
          // Update the item in the meal
          const { mealId, timestamp, ...itemWithoutMealData } = newItem;
          meal.items[itemIndex] = itemWithoutMealData;
          meal.updatedAt = new Date().toISOString();
          
          // Save updated meals
          await this.saveMealsToFile(meals);
          
          // Regenerate the meal note
          await this.createMealNote(meal);
          
          new Notice(`‚úÖ Meal item updated: ${newItem.food} in "${meal.name}"`);
          mealFound = true;
          break;
        }
      }
      
      if (!mealFound) {
        console.warn('‚ö†Ô∏è Could not find meal containing the item to update');
        new Notice('‚ö†Ô∏è Could not find the meal containing this item');
      }
      
    } catch (error) {
      console.error('Error updating meal item:', error);
      new Notice(`‚ùå Failed to update meal item: ${error.message}`);
      throw error;
    }
  }
} 