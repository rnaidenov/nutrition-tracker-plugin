import { TFile, Vault, Notice } from 'obsidian';
import { FoodItem, NutritionData } from '../types/nutrition';
import { PluginSettings } from '../types/settings';

export class FileService {
  constructor(private vault: Vault, private settings: PluginSettings) {}

  async createOrUpdateFoodLog(foodItems: FoodItem[]): Promise<void> {
    const today = this.getTodayString();
    const logPath = `${this.settings.logStoragePath}/${today}.md`;
    
    try {
      // Ensure the directory exists
      await this.ensureDirectoryExists(this.settings.logStoragePath);
      
      // Check if file already exists
      const existingFile = this.vault.getAbstractFileByPath(logPath);
      
      if (existingFile instanceof TFile) {
        // Append to existing file
        await this.appendToExistingLog(existingFile, foodItems);
      } else {
        // Create new file
        await this.createNewFoodLog(logPath, foodItems);
      }
      
      new Notice(`Food log updated: ${today}.md`);
    } catch (error) {
      console.error('Error creating/updating food log:', error);
      throw new Error(`Failed to save food log: ${error.message}`);
    }
  }

  private async createNewFoodLog(path: string, foodItems: FoodItem[]): Promise<void> {
    const content = await this.generateFoodLogContent(foodItems, true);
    await this.vault.create(path, content);
  }

  private async appendToExistingLog(file: TFile, foodItems: FoodItem[]): Promise<void> {
    const existingContent = await this.vault.read(file);
    const newEntries = await this.generateFoodLogContent(foodItems, false);
    
    // Find the position to insert new entries (before the daily summary)
    const summaryRegex = /## Daily Summary/;
    const match = existingContent.match(summaryRegex);
    
    if (match) {
      // Insert before the summary
      const beforeSummary = existingContent.substring(0, match.index);
      const afterSummary = existingContent.substring(match.index);
      const updatedContent = beforeSummary + newEntries + '\n' + afterSummary;
      
      // Recalculate totals
      const finalContent = await this.recalculateTotals(updatedContent);
      await this.vault.modify(file, finalContent);
    } else {
      // No summary found, just append
      const updatedContent = existingContent + '\n' + newEntries;
      await this.vault.modify(file, updatedContent);
    }
  }

  private async generateFoodLogContent(foodItems: FoodItem[], isNewFile: boolean): Promise<string> {
    const today = this.getTodayString();
    const totals = this.calculateTotals(foodItems);
    
    let content = '';
    
    if (isNewFile) {
      content += `# Food Log ${today}\n\n`;
      content += `## Today's Meals\n\n`;
    }
    
    // Add food items
    for (const item of foodItems) {
      content += `### ${item.food}\n`;
      content += `- **Quantity**: ${item.quantity}\n`;
      content += `- **Calories**: ${item.calories} kcal\n`;
      content += `- **Protein**: ${item.protein}g\n`;
      content += `- **Carbs**: ${item.carbs}g\n`;
      content += `- **Fat**: ${item.fat}g\n`;
      if (item.timestamp) {
        const time = new Date(item.timestamp).toLocaleTimeString('en-US', { 
          hour: '2-digit', 
          minute: '2-digit' 
        });
        content += `- **Time**: ${time}\n`;
      }
      content += '\n';
    }
    
    if (isNewFile) {
      content += await this.generateDailySummary(totals);
    }
    
    return content;
  }

  private async generateDailySummary(totals: NutritionData): Promise<string> {
    const goals = this.settings.nutritionGoals;
    
    let summary = '## Daily Summary\n\n';
    summary += `**Total Calories**: ${totals.calories} / ${goals.calories} kcal\n`;
    summary += `**Total Protein**: ${totals.protein} / ${goals.protein}g\n`;
    summary += `**Total Carbs**: ${totals.carbs} / ${goals.carbs}g\n`;
    summary += `**Total Fat**: ${totals.fat} / ${goals.fat}g\n\n`;
    
    summary += '## Progress\n';
    summary += `- Calories: ${this.calculatePercentage(totals.calories, goals.calories)}%\n`;
    summary += `- Protein: ${this.calculatePercentage(totals.protein, goals.protein)}%\n`;
    summary += `- Carbs: ${this.calculatePercentage(totals.carbs, goals.carbs)}%\n`;
    summary += `- Fat: ${this.calculatePercentage(totals.fat, goals.fat)}%\n\n`;
    
    summary += '---\n';
    summary += '*Generated by Nutrition Tracker Plugin*\n';
    
    return summary;
  }

  private async recalculateTotals(content: string): Promise<string> {
    // Extract all nutrition values from the content
    const foodItems = this.extractFoodItemsFromContent(content);
    const totals = this.calculateTotals(foodItems);
    
    // Replace the daily summary section
    const summaryRegex = /## Daily Summary[\s\S]*?(?=\n##|\n---|$)/;
    const newSummary = await this.generateDailySummary(totals);
    
    return content.replace(summaryRegex, newSummary.trim());
  }

  private extractFoodItemsFromContent(content: string): FoodItem[] {
    const items: FoodItem[] = [];
    const itemRegex = /### (.+?)\n- \*\*Quantity\*\*: (.+?)\n- \*\*Calories\*\*: ([\d.]+) kcal\n- \*\*Protein\*\*: ([\d.]+)g\n- \*\*Carbs\*\*: ([\d.]+)g\n- \*\*Fat\*\*: ([\d.]+)g/g;
    
    let match;
    while ((match = itemRegex.exec(content)) !== null) {
      items.push({
        food: match[1],
        quantity: match[2],
        calories: parseFloat(match[3]),
        protein: parseFloat(match[4]),
        carbs: parseFloat(match[5]),
        fat: parseFloat(match[6])
      });
    }
    
    return items;
  }

  private calculateTotals(foodItems: FoodItem[]): NutritionData {
    return foodItems.reduce((totals, item) => ({
      calories: totals.calories + (item.calories || 0),
      protein: totals.protein + (item.protein || 0),
      carbs: totals.carbs + (item.carbs || 0),
      fat: totals.fat + (item.fat || 0)
    }), { calories: 0, protein: 0, carbs: 0, fat: 0 });
  }

  private calculatePercentage(current: number, goal: number): number {
    if (goal === 0) return 0;
    return Math.round((current / goal) * 100);
  }

  private getTodayString(): string {
    const today = new Date();
    return today.toISOString().split('T')[0]; // YYYY-MM-DD
  }

  private async ensureDirectoryExists(path: string): Promise<void> {
    const dirs = path.split('/');
    let currentPath = '';
    
    for (const dir of dirs) {
      currentPath = currentPath ? `${currentPath}/${dir}` : dir;
      
      const exists = this.vault.getAbstractFileByPath(currentPath);
      if (!exists) {
        await this.vault.createFolder(currentPath);
      }
    }
  }

  async saveImage(imageFile: File): Promise<string> {
    try {
      await this.ensureDirectoryExists(this.settings.imageStoragePath);
      
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const extension = imageFile.name.split('.').pop() || 'jpg';
      const filename = `food-image-${timestamp}.${extension}`;
      const imagePath = `${this.settings.imageStoragePath}/${filename}`;
      
      // Convert File to ArrayBuffer
      const arrayBuffer = await imageFile.arrayBuffer();
      await this.vault.createBinary(imagePath, arrayBuffer);
      
      return imagePath;
    } catch (error) {
      console.error('Error saving image:', error);
      throw new Error(`Failed to save image: ${error.message}`);
    }
  }
} 